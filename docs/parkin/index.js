"use strict";function _defineProperty(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _classPrivateFieldGet(e,t){return _classApplyDescriptorGet(e,_classExtractFieldDescriptor(e,t,"get"))}function _classPrivateFieldSet(e,t,r){return _classApplyDescriptorSet(e,_classExtractFieldDescriptor(e,t,"set"),r),r}function _classExtractFieldDescriptor(e,t,r){if(!t.has(e))throw new TypeError("attempted to "+r+" private field on non-instance");return t.get(e)}function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}function _classApplyDescriptorSet(e,t,r){if(t.set)t.set.call(e,r);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=r}}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function _classPrivateFieldInitSpec(e,t,r){_checkPrivateRedeclaration(e,t),t.set(e,r)}Object.defineProperty(exports,"__esModule",{value:!0});const isArr=e=>Array.isArray(e),isObj=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,isFunc=e=>"function"==typeof e,isStr=e=>"string"==typeof e,equalsNaN=e=>"number"==typeof e&&e!=e,deepFreeze=e=>(Object.freeze(e),Object.getOwnPropertyNames(e).map((t=>{e.hasOwnProperty(t)&&null!==e[t]&&("object"==typeof e[t]||isFunc(e[t]))&&!Object.isFrozen(e[t])&&deepFreeze(e[t])})),e),noOp=()=>{},noOpObj=Object.freeze({});deepFreeze({content:{}}),deepFreeze([]);const exists=e=>e==e&&null!=e,eitherArr=(e,t)=>isArr(e)?e:t,toStr=e=>null==e?"":isStr(e)?e:JSON.stringify(e),isColl=e=>"object"==typeof e&&null!==e,updateColl=(e,t,r,s)=>{const n=e;if(!isColl(e)||!e||!t)return"set"!==r&&s||void 0;const a=isArr(t)?Array.from(t):t.split("."),i=a.pop();let o,c;for(;o=a.shift();){const t=e[o];if(isColl(t)||isFunc(t)?e=t:("set"===r?e[o]={}:c=!0,e=e[o]),c)return s}return"get"===r?i in e?e[i]:s:"unset"===r?delete e[i]:(e[i]=s)&&n||n},get=(e,t,r)=>updateColl(e,t,"get",r),checkCall=(e,...t)=>isFunc(e)?e(...t):void 0;Array.from(["caller","callee","arguments","apply","bind","call","toString","__proto__","__defineGetter__","__defineSetter__","hasOwnProperty","__lookupGetter__","__lookupSetter__","isPrototypeOf","propertyIsEnumerable","valueOf","toLocaleString"]).concat(Object.getOwnPropertyNames(Object.prototype)).reduce(((e,t)=>(e[t]=!0,e)),{});const isRegex=e=>Boolean(e&&e instanceof RegExp),getRegexSource=e=>{return t=e,Boolean(t&&t instanceof RegExp)?e.source:isStr(e)?e:null;var n},parseArgs=e=>{if(isArr(e[0]))return[e[0],e[1]];const t=e[e.length-1],r=isStr(t)?t:void 0;return[r?e.splice(0,e.length-1):e,r]},joinRegex=(...e)=>{const[t,r]=parseArgs(e),s=t.reduce(((e,t)=>{const r=(n=s=t,Boolean(n&&n instanceof RegExp)?s.source:isStr(s)?s:null);var s,n;return r?""===e?r:`${e}|${r}`:e}),"");return new RegExp(`(${s})`,r)},capitalize=(e,t=!0)=>{if(!isStr(e)||!e[0])return e;const r=t?e.slice(1).toLowerCase():e.slice(1);return`${e[0].toUpperCase()}${r}`},quoteSymbols=['"',"'"],isQuoted=(e,t=quoteSymbols)=>isStr(e)&&t.some((t=>e.startsWith(t)&&e.endsWith(t))),reverseStr=e=>{if(!isStr(e))return;let t="";for(let r of e)t=r+t;return t},getNearestDelimiterIndex=(e,t,r)=>r.map((r=>e.indexOf(r,t))).sort().find((e=>e>=0)),getWordStartingAt=(e,t,r=[" "])=>{const s=getNearestDelimiterIndex(e,t,r);return e.substring(t,-1===s?e.length:s)},getWordEndingAt=(e,t,r=[" "])=>{const s=reverseStr(e),n=e.length-t;return reverseStr(getWordStartingAt(s,n,r))},getRXMatch=(e,t,r)=>e.match(t)[r].trim(),sanitizeForId=e=>`${e.trim().toLowerCase().replace(/[\s\/\\\(\)\+=_&%\$#@!\*~`\|\?:;"'<>,.{}]/g,"-")}-${e.length}`,sanitize=e=>{let t=e.match.toString();return"/"===t[0]&&(t=t.substr(1)),"^"===t[0]&&(t=t.substr(1)),"/"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),"$"===t.charAt(t.length-1)&&(t=t.slice(0,-1)),t.replace(/\(\?:([^\|]+)+\|+([^\)]+)?\)/,"$1")},validateDefinition=(e,t)=>t.reduce(((e,t)=>!(!e||t.content===e.content)&&(t.uuid===e.uuid&&(e.uuid=`${e.uuid}-${e.content.length}`),e)),{...e}),removeQuotes=e=>e.trim().replace(/^("|')/,"").replace(/("|')$/,""),RX_OPTIONAL=/\w*\([^)]*?\)/,RX_ALT=/\s*\S*\/\S*\s*/,RX_PARAMETER=/\s*{(.*?)}\s*/,RX_EXPRESSION=joinRegex(RX_PARAMETER,RX_OPTIONAL,"g"),RX_ANY=/(.*)/,RX_MATCH_REPLACE=/{|}/g,RX_DOUBLE_QUOTED=/"[^"]+"/,RX_SINGLE_QUOTED=/'[^']+'/,RX_FLOAT=/-?[0-9]+[.][0-9]+/,RX_INT=/-?[0-9]+/,RX_WORLD=/^["]?\$world\.\S+["]?/,RX_WORLD_REPLACE=/(\$:world|\$world)+\.[^"'\s]*/gm,testMethodFill=e=>()=>{throw new Error(`Test method ${e} does not exist on the global scope.\nPlease ensure ${e} exists before calling the run method!\n`)},throwMissingSteps=()=>{throw new Error("Runner class constructor requires an instance of the Steps class")},throwMissingFeatureText=()=>{throw new Error("Runner class requires feature text when calling the run method")},throwNoMatchingStep=e=>{throw new ReferenceError(e)},throwParamTypeExists=()=>{throw new Error(`Cannot register param type "${name}". It already exists!`)},throwFeatureNotAnObj=e=>{throw new Error("Assemble feature requires an object matching the feature model spec!",e)},throwMissingWorldValue=(e,t)=>{throw new Error(`Can not replace ${e} with value from $world, it does not exist on the world object`,t,e)},throwInvalidHookType=(e,t)=>{throw new Error([`Expected client hook type to be one of ', ${e}.`,`Found: ${t}`].join("\n"))},throwWorldReplace=(e,t)=>{throw console.log(`Error in $world replace of text content. Current match was ${t}`),e},checkWorldValue=(e,t)=>(r,s)=>{const n=r.match(RX_WORLD);if(!isObj(s)||!n)return matchType(e(r),t);const a=get(s,removeQuotes(r).replace("$world.",""));return exists(a)?matchType(a,t):throwMissingWorldValue(r,s)},matchType=(e,t)=>typeof e===t?e:null,typeModel={name:"",regex:"",type:"string",useForSnippets:!0,preferForRegexpMatch:!1,transformer:checkWorldValue((e=>e),"string")},__paramTypes={any:{...typeModel,name:"any",regex:RX_ANY},word:{...typeModel,name:"word",regex:RX_ANY,transformer:checkWorldValue((e=>{return isQuoted(e)?void 0:null==(t=e)?"":isStr(t)?t:JSON.stringify(t);var t}),typeModel.type)},float:{...typeModel,name:"float",type:"number",regex:RX_FLOAT,transformer:checkWorldValue((e=>{const t=parseFloat(e);return equalsNaN(t)?void 0:t}),"number")},int:{...typeModel,name:"int",type:"number",regex:RX_INT,transformer:checkWorldValue((e=>{const t=parseInt(e);return equalsNaN(t)||e.includes(".")?void 0:t}),"number")},string:{...typeModel,name:"string",regex:joinRegex(RX_DOUBLE_QUOTED,RX_SINGLE_QUOTED),transformer:checkWorldValue((e=>isQuoted(e)?removeQuotes(e):void 0),typeModel.type)}},getParamTypes=()=>__paramTypes,registerParamType=(e=noOpObj,t=e.name)=>__paramTypes[t]?throwParamTypeExists():(__paramTypes[t]={...typeModel,...e},__paramTypes[t].transformer=checkWorldValue(__paramTypes[t].transformer,__paramTypes[t].type),__paramTypes),convertTypes=(e,t,r)=>e.map(((e,s)=>{const n=t[s]||__paramTypes.any;return checkCall(n.transformer,e,r)})).filter(exists),matchRegex=(e,t)=>{const r=t.match(new RegExp(e.match));return r?{definition:e,match:r.slice(1,r.length).filter(Boolean)}:noOpObj},toAlternateRegex=e=>{const t=e.split(/(\(|\))/),[r,,s,,n]=t;return""===r&&""===n?e+"?":""===r?`(${s}|${s}${n})`:""===n?`(${r}|${r}${s})`:`(${r}${n}|${r}${s}${n})`},getFullOptionalText=e=>{const t=e.input;return getWordEndingAt(t,e.index)+e[0]},getOptionalRegex=e=>{const t=getFullOptionalText(e);return toAlternateRegex(t)},getParamRegex=e=>{const t=getParamTypes();return(t[e]||t.any).regex.source},getAlternateRegex=e=>`(${e.trim().replace(/\//g,"|")})`,getMatchRegex=(e,t)=>{const[r,s]=t;switch(e){case"parameter":return new RegExp(getParamRegex(s));case"optional":return new RegExp(getOptionalRegex(t));case"alternate":return new RegExp(getAlternateRegex(r));default:return null}},parseMatch=(e,t="other")=>{const r=e[0];return{text:r.trim(),index:e.index,input:e.input,regex:getMatchRegex(t,e),type:t,..."parameter"===t&&{paramType:r.trim().replace(RX_MATCH_REPLACE,"")}}},getRegexParts=e=>[...[...e.matchAll(new RegExp(RX_PARAMETER,"gi"))].map((e=>parseMatch(e,"parameter"))),...[...e.matchAll(new RegExp(RX_OPTIONAL,"gi"))].map((e=>parseMatch(e,"optional"))),...[...e.matchAll(new RegExp(RX_ALT,"gi"))].map((e=>parseMatch(e,"alternate")))].sort(((e,t)=>e.index-t.index)),constants=deepFreeze({REGEX_VARIANT:"regex",WORLD_AT_RUNTIME:"$:",EXPRESSION_VARIANT:"expression",STEP_TYPES:["given","when","then","and","but"],HOOK_TYPES:["beforeAll","afterAll","beforeEach","afterEach"],FEATURE_META:["feature","perspective","desire","reason","comments"],LOG_JEST_SPEC_ENV:"PARKIN_LOG_JEST_SPEC",SPEC_RESULT_LOG:"------- PARKIN SPEC RESULT LOG -------"}),hasWindow=Boolean("undefined"!=typeof window),hasGlobal=Boolean("undefined"!=typeof global),hasModule=Boolean("object"==typeof module),hasRequire=Boolean("function"==typeof require),hasJasmine=Boolean(hasGlobal&&void 0!==global.jasmine),resolveJasmine=()=>hasJasmine?checkCall((()=>global.jasmine)):{getEnv:()=>noOpObj},resolveModule=()=>hasModule?checkCall((()=>module)):{exports:{}},resolveRequire=()=>hasRequire?checkCall((()=>require)):noOp,resolveGlobalObj=()=>{try{return hasWindow?checkCall((()=>window)):hasGlobal?checkCall((()=>global)):noOpObj}catch(e){return noOpObj}},escapeStr=e=>hasWindow?e.replace(/[|\\[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d"):e.replace(/[|\\[\]^$+*?.]/g,"\\$&"),runRegexCheck=(e,t,r)=>{if(!t.test(e))return e;let s=e;return e.replace(t,((...e)=>{const t=e[0].trim(),[n,...a]=s.split(t),i=isFunc(r)?r(...e):r;s=`${n}${i}${a.join(t)}`})),s},convertToRegex=e=>{const t=getParamTypes(),r=[];return{regex:runRegexCheck(e,RX_EXPRESSION,((e,...s)=>{const n=e.trim().replace(RX_MATCH_REPLACE,""),a=e.match(RX_PARAMETER),i=e.match(RX_OPTIONAL);return a&&r.push(t[n]||t.any),a?getParamRegex(n):i?toAlternateRegex(e):e})),transformers:r}},checkAlternative=e=>({regex:runRegexCheck(e,new RegExp(RX_ALT,"g"),getAlternateRegex),altIndexes:[]}),checkAnchors=e=>{let t=e;return e.startsWith("^")||(t="^"+t),e.endsWith("$")||(t+="$"),{regex:t}},extractParameters=(e,t,r)=>{const s=[...[...(n=t).matchAll(new RegExp(RX_PARAMETER,"gi"))].map((e=>parseMatch(e,"parameter"))),...[...n.matchAll(new RegExp(RX_OPTIONAL,"gi"))].map((e=>parseMatch(e,"optional"))),...[...n.matchAll(new RegExp(RX_ALT,"gi"))].map((e=>parseMatch(e,"alternate")))].sort(((e,t)=>e.index-t.index));var n;const a=s.filter((e=>"parameter"===e.type)).length,i=s.reduce(((t,s)=>{const{params:n,textIndex:a,wordMatchIndex:i}=t,o=e.substring(a),c="word"===s.paramType,l=o.match(s.regex),u={0:r[i],index:o.indexOf(r[i])},p=c?u:l;return p?("parameter"===s.type&&p&&n.push(p[0]),{params:n,textIndex:a+(p&&p.index+p[0].length),wordMatchIndex:i+(c&&1)}):t}),{params:[],textIndex:0,wordMatchIndex:0});return a===i.params.length?i.params:null},matchExpression=(e,t,r)=>{if(e.match===t)return{definition:e,match:[]};const s=(n=e.match,hasWindow?n.replace(/[|\\[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d"):n.replace(/[|\\[\]^$+*?.]/g,"\\$&"));var n;const{regex:a}=checkAlternative(s),{regex:i,transformers:o}=convertToRegex(a),{regex:c}=checkAnchors(i),l=matchRegex({...e,match:c},t);if(!l||!l.definition||!l.match)return noOpObj;const u=extractParameters(t,e.match,l.match);if(!u)return noOpObj;const p=convertTypes(u,o,r);return p.length!==u.length?noOpObj:{definition:e,match:p}},{REGEX_VARIANT:REGEX_VARIANT$1}=constants,matcher=(e,t,r)=>e.reduce(((e,s)=>e.match||!s.match?e:s.variant!==REGEX_VARIANT$1?matchExpression(s,t,r):matchRegex(s,t)),noOpObj),{REGEX_VARIANT:REGEX_VARIANT,EXPRESSION_VARIANT:EXPRESSION_VARIANT,STEP_TYPES:STEP_TYPES}=constants,getContent=e=>{const t=e.variant===REGEX_VARIANT?e.match.toString():`"${e.match}"`;return`${capitalize(e.type)}(${t}, ${e.method.toString()})`},registerFromCall=function(e,t,r,s,n=noOpObj){const a={type:t,meta:n,match:r,method:s,tokens:[],variant:0===r.toString().indexOf("/")?REGEX_VARIANT:EXPRESSION_VARIANT};a.name=sanitize(a),a.uuid=sanitizeForId(`${t}-${a.name}`),a.content=getContent(a);const i=this.list(),o=validateDefinition(a,i);return o&&this[e].push(o),o},tempRegister=(e,t,r)=>(...s)=>{const n=e[t](...s);return r[t].push(n),n},registerFromParse=function(e){const t=this.types.map((e=>capitalize(e))),r=t.reduce(((e,t)=>(e[t]=[],e)),{});return eitherArr(e,[e]).map((e=>{Function(`return (global, require, module, ${t.join(",")}) => {\n          return (function(global) { ${e} }).call(global, global)\n        }`)()(resolveGlobalObj(),hasRequire?checkCall((()=>require)):noOp,hasModule?checkCall((()=>module)):{exports:{}},...t.map((e=>tempRegister(this,e,r))))})),r},joinAllSteps=e=>e.types.reduce(((t,r)=>t.concat(e[`_${r}`])),[]);class Steps{constructor(e){_defineProperty(this,"types",STEP_TYPES),_defineProperty(this,"list",(()=>{return(e=this).types.reduce(((t,r)=>t.concat(e[`_${r}`])),[]);var e})),_defineProperty(this,"typeList",(()=>this.types.reduce(((e,t)=>{const r=`_${t}`;return e[r]=[...this[r]],e}),{}))),_defineProperty(this,"match",(e=>{const t=this.list(),r=matcher(t,e,this._world);return!(!r.match||!r.definition)&&(r.match.push(this._world),r)})),_defineProperty(this,"resolve",(e=>{const t=this.match(e);return t?t.definition.method(...t.match):throwNoMatchingStep(`Matching definition could not be found for step: "${e}"`)})),_defineProperty(this,"register",((...e)=>isStr(e[0])?registerFromCall.apply(this,e):registerFromParse.apply(this,e))),_defineProperty(this,"clear",(()=>{this.types.map((e=>this[`_${e}`]=[]))})),this._world=e||{};const t=this;this.types.map((e=>{const r=`_${e}`;this[r]=[],this[capitalize(e)]=(s,n,a)=>t.register(r,e,s,n,a)}))}}const{HOOK_TYPES:HOOK_TYPES}=constants;class Hooks{constructor(){_defineProperty(this,"types",HOOK_TYPES),_defineProperty(this,"getRegistered",(e=>this.types.includes(e)?this._registeredHooks[e]||noOp:throwInvalidHookType(HOOK_TYPES.join(", "),e))),this._registeredHooks={},this.types.map((e=>{this[e]=t=>{isFunc(t)&&(this._registeredHooks[e]=t)}}))}}const RX_GIVEN=/^\s*Given (.*)$/,RX_WHEN=/^\s*When(.*)$/,RX_THEN=/^\s*Then (.*)$/,RX_AND=/^\s*And (.*)$/,RX_BUT=/^\s*But (.*)$/,RX_ASTERISK=/^\s*\* (.*)$/,RX_DOC_QUOTES=/^\s*?"""\s*?/,RX_DOC_TICKS=/^\s*?```\s*?/,RX_DATA_TABLE=/^\s*?\|/,RegStepTags=[{regex:RX_GIVEN,type:"given"},{regex:RX_WHEN,type:"when"},{regex:RX_THEN,type:"then"},{regex:RX_AND,type:"and"},{regex:RX_BUT,type:"but"},{regex:RX_ASTERISK,type:"and"}],checkDataTable=(e,t,r,s)=>{if(!RX_DATA_TABLE.test(r))return e;let n;return e.table={index:s,content:t.reduce(((e,t)=>(n=n||!RX_DATA_TABLE.test(t),!n&&e.push(t.split("|").reduce(((e,t)=>{const r=t.trim();return r&&e.push(r),e}),[])),e)),[])},e},checkDocString=(e,t,r,s)=>{let n=RX_DOC_QUOTES.test(r)&&'"""';if(n=n||RX_DOC_TICKS.test(r)&&"```",!n)return e;const a=r.split(n)[0],i=new Array(a.length).fill("\\s").join(""),o=new RegExp(`^${i}`);return e.doc={index:s,whiteSpace:a,type:'"""'===n?"quote":"tick",content:t.split(n).slice(1).shift().trim().split("\n").reduce(((e,t)=>(e.push(t.replace(o,"").trim()),e)),[]).join("\n")},e},stepFactory=(e,t,r,s)=>{let n={type:e,index:s,step:t,uuid:sanitizeForId(`${e}-${t}`)};const a=s+1,i=r[a],o=r.slice(a);return n=checkDataTable(n,o,i,a),n=checkDocString(n,o.join("\n"),i,a),n},parseStep=(e,t,r,s)=>RegStepTags.reduce(((n,a)=>{if(n)return n;const i=a.regex.test(r);return i&&e.steps.push(stepFactory(a.type,getRXMatch(r,a.regex,1),t,s)),i}),!1),{WORLD_AT_RUNTIME:WORLD_AT_RUNTIME}=constants,worldReplace=(e,t)=>{let r;try{return e.replace(RX_WORLD_REPLACE,(e=>{r=e;const s=e.trim();if(0===s.indexOf(WORLD_AT_RUNTIME))return s.replace(WORLD_AT_RUNTIME,"$");const n=s.replace(/^\$world\./,""),a=get(t,n);return isFunc(a)?a(t,path):exists(a)?a:e}))}catch(e){throwWorldReplace(e,r)}},RX_NEWLINE=/\r?\n/g,RX_TAG=/^\s*@(.*)$/,RX_COMMENT=/^\s*#(.*)$/,RX_FEATURE=/^\s*Feature:(.*)$/,RX_RULE=/^\s*Rule:(.*)$/,RX_AS=/^\s*As (.*)$/,RX_I_WANT=/^\s*I want (.*)$/,RX_SO_THAT=/^\s*So that (.*)$/,RX_IN_ORDER=/^\s*In order (.*)$/,RX_SCENARIO=/^\s*Scenario:(.*)$/,RX_EXAMPLE=/^\s*Example:(.*)$/,RX_BACKGROUND=/^\s*Background:(.*)$/,featureMetaTags=[{regex:RX_AS,key:"perspective"},{regex:RX_I_WANT,key:"desire"},{regex:RX_SO_THAT,key:"reason"},{regex:RX_IN_ORDER,key:"reason"}],featureFactory=(e,t,r)=>({index:r,content:t,feature:e,tags:[],rules:[],reason:[],comments:[],scenarios:[],...e&&{uuid:sanitizeForId(e)}}),ruleFactory=(e,t)=>({index:t,rule:e,tags:[],scenarios:[],...e&&{uuid:sanitizeForId(e)}}),scenarioFactory=(e,t)=>({index:t,scenario:e,tags:[],steps:[],...e&&{uuid:sanitizeForId(e)}}),backgroundFactory=(e,t)=>({index:t,steps:[],background:e,...e&&{uuid:sanitizeForId(e)}}),addReason=(e,t,r)=>{t&&e.reason.push({content:t,index:r})},featureMeta=(e,t,r)=>{let s=!1;return featureMetaTags.reduce(((n,a)=>{if(n)return n;const i=a.regex.test(t);return!s&&i&&(s=!0),i?"reason"===a.key?addReason(e,getRXMatch(t,a.regex,0),r):e[a.key]={content:getRXMatch(t,a.regex,0),index:r}:i}),!1),s},checkTag=(e,t,r,s)=>{if(!RX_TAG.test(r))return!1;const n=e.background?t:e,a=getRXMatch(r,RX_TAG,0);return n.tags=(n.tags||[]).concat(a.split(" ")),!0},featureComment=(e,t,r)=>{if(!RX_COMMENT.test(t))return!1;const s=t.match(RX_COMMENT)[0];return e.comments.push({content:s,index:r}),!0},ensureFeature=(e,t,r,s,n)=>{if(!RX_FEATURE.test(r))return t;const a=getRXMatch(r,RX_FEATURE,1);if(!t.feature)return t.feature=a,t.index||(t.index=n),t.uuid||(t.uuid=sanitizeForId(t.feature)),!e.includes(t)&&e.push(t),t;const i=featureFactory(a,s,n);return e.push(i),i},ensureRule=(e,t,r,s)=>{if(!RX_RULE.test(r))return t;let n=getRXMatch(r,RX_RULE,1);return t.rule?t=ruleFactory(n,s):t.rule=n,!t.index&&(t.index=s),!t.uuid&&(t.uuid=sanitizeForId(t.rule)),!e.rules.includes(t)&&e.rules.push(t),t},ensureScenario=(e,t,r,s,n)=>{const a=RX_SCENARIO.test(s);if(!a&&!RX_EXAMPLE.test(s))return r;let i=a&&getRXMatch(s,RX_SCENARIO,1);i=i||getRXMatch(s,RX_EXAMPLE,1),r.scenario?r=scenarioFactory(i,n):r.scenario=i,!r.index&&(r.index=n),!r.uuid&&(r.uuid=sanitizeForId(r.scenario));const o=t.uuid?t:e;return!o.scenarios.includes(r)&&o.scenarios.push(r),r},ensureBackground=(e,t,r,s,n)=>{if(!RX_BACKGROUND.test(s))return r;const a=t.uuid?t:e,i=`${a.uuid}-background`;return r.background?r=backgroundFactory(i,n):r.background=i||"",!r.index&&(r.index=n),!r.uuid&&(r.uuid=sanitizeForId(r.background)),a.background=r,r},setActiveParent=(e,t,r,s,n,a)=>RX_SCENARIO.test(a)||RX_EXAMPLE.test(a)?s:RX_FEATURE.test(a)?t:RX_RULE.test(a)?r:RX_BACKGROUND.test(a)?n:e,parseFeature=function(e,t){t=t||this&&this.world||noOpObj;const r=worldReplace((e||"").toString(),t).split(RX_NEWLINE);let s=ruleFactory(!1),n=scenarioFactory(!1),a=backgroundFactory(!1),i=featureFactory(!1,e),o=i;return r.reduce(((t,c,l)=>(i=ensureFeature(t,i,c,e,l),featureComment(i,c,l)||featureMeta(i,c,l)?t:(s=ensureRule(i,s,c,l),n=ensureScenario(i,s,n,c,l),a=ensureBackground(i,s,a,c,l),parseStep(o,r,c,l)||(o=setActiveParent(o,i,s,n,a,c),checkTag(o,i,c)),t))),[])},parseDefinition=function(e){return this.steps.register([e])},{SPEC_RESULT_LOG:SPEC_RESULT_LOG,LOG_JEST_SPEC_ENV:LOG_JEST_SPEC_ENV}=constants,logResultToTerminal=e=>{const t=(new Date).getTime();get(process,`env.${LOG_JEST_SPEC_ENV}`)&&process.stdout.write([SPEC_RESULT_LOG,JSON.stringify({...e,timestamp:t}),SPEC_RESULT_LOG].join(""))},getSuiteData=e=>{const t=get(e,"description"),r=t?t.startsWith("Scenario >")?"Scenario":t.startsWith("Background >")?"Background":t.startsWith("Rule >")?"Rule":"Feature":"Feature";return{type:r.toLowerCase(),..."Feature"!==r&&{description:t.replace(`${r} >`,`${r}:`)}}},getTestMethod=(e,t)=>t?noOp:global[e]||testMethodFill(e),buildReporter=e=>{const t=[],r=e.describe;return e.describe=(...e)=>{const s=r.apply(null,e);return t.push(s),s},{suiteStarted:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"start"})},specStarted:e=>{logResultToTerminal({...e,type:"step",action:"start"})},specDone:e=>{if(logResultToTerminal({...e,type:"step",action:"end"}),"failed"!==e.status)return;const r=t.find((t=>t.children.find((t=>t.result===e))));r&&r.children.map((e=>e.disable()))},suiteDone:e=>{logResultToTerminal({...e,...getSuiteData(e),action:"end"})}}},skipTestsOnFail=e=>{if(!hasJasmine)return;const t=(hasJasmine?checkCall((()=>global.jasmine)):{getEnv:()=>noOpObj}).getEnv();t&&t.describe&&t.addReporter(buildReporter(t))},buildTitle=(e,t)=>`${capitalize(t)} > ${e}`,resolveFeatures=(e,t)=>isStr(e)?parseFeature(e,t):isObj(e)?[e]:isArr(e)?e.reduce(((e,r)=>e.concat(resolveFeatures(r,t))),[]):throwMissingFeatureText(),runStep=async(e,t,r)=>{getTestMethod("test",r)(`${capitalize(t.type)} ${t.step}`,(async()=>await e.resolve(t.step)))},loopSteps=(e,t,r,s)=>(getTestMethod("describe",s)(t,(()=>{const t=e.steps.map((e=>runStep(r,e,s)));Promise.all(t)})),[]),runScenario=(e,t,r,s)=>(r&&loopSteps(r,buildTitle(t.scenario,"Background"),e,s),loopSteps(t,buildTitle(t.scenario,"Scenario"),e,s)),runRule=(e,t,r,s)=>{let n=[];return describe(`Rule > ${t.rule}`,(()=>{n=t.scenarios.map((n=>runScenario(e,n,r||t.background,s))),Promise.all(n)})),n},parseFeatureTags=e=>isStr(e)&&e.match(/[@]\w*/g),itemMatch=(e="",t=[],r={})=>{const{name:s,tags:n}=r,a=isStr(n)?parseFeatureTags(n):eitherArr(n,[]),i=!s||e.includes(s),o=!a.length||a.every((e=>t.includes(e)));return i&&o},filterFeatures=(e,t={})=>e.reduce(((e,r)=>{if(itemMatch(r.feature,r.tags,t))return e.push(r),e;const s=r.scenarios.filter((e=>itemMatch(e.scenario,[...e.tags||[],...r.tags||[]],t)));return s.length&&e.push({...r,scenarios:s}),e}),[]);class Runner{constructor(e,t,r){_defineProperty(this,"getFeatures",((e,t)=>{const r=resolveFeatures(e,this._world);return filterFeatures(r,t)})),_defineProperty(this,"run",(async(e,t=noOpObj)=>{const r=this.run.PARKIN_TEST_MODE;skipTestsOnFail();const s=getTestMethod("describe",r),n=getTestMethod("beforeAll",r),a=getTestMethod("afterAll",r),i=getTestMethod("beforeEach",r),o=getTestMethod("afterEach",r),c=this.getFeatures(e,t);if(!c.length)return!1;const l=await c.map((async e=>{let t=[];return n(this.hooks.getRegistered("beforeAll")),a(this.hooks.getRegistered("afterAll")),i(this.hooks.getRegistered("beforeEach")),o(this.hooks.getRegistered("afterEach")),s(buildTitle(e.feature,"Feature"),(()=>{t=e.rules.map((t=>runRule(this.steps,t,e.background,r))),t.concat(e.scenarios.map((t=>runScenario(this.steps,t,e.background,r)))),Promise.all(t)})),t}));return await Promise.all(l),!0})),!e&&throwMissingSteps(),!t&&throwMissingHooks(),this.steps=e,this.hooks=t,this._world=r}}const{FEATURE_META:FEATURE_META}=constants,addContent=(e,t,r)=>{exists(r)?exists(e[r])?e.splice(r,0,t):e[r]=t:e.push(t)},addTags=(e,t,r="")=>{isArr(t)&&t.length&&addContent(e,`${r}${t.join(" ")}`)},addMeta=(e,t)=>{FEATURE_META.map((r=>{switch(r){case"feature":addContent(e,`Feature: ${t[r]}`,t.index);break;case"comments":isArr(t[r])&&t[r].map((t=>addContent(e,t.content,t.index)));break;case"reason":isArr(t[r])&&t[r].map((t=>addContent(e,`  ${t.content}`,t.index)));break;case"desire":case"perspective":t[r]&&addContent(e,`  ${t[r].content}`,t[r].index)}}))},addSteps=(e,t)=>{isArr(t.steps)&&t.steps.length&&t.steps.map((t=>addContent(e,`    ${capitalize(t.type)} ${t.step}`,t.index)))},addScenarios=(e,t)=>{t.scenarios&&t.scenarios.map((t=>{addTags(e,t.tags,"  "),addContent(e,`  Scenario: ${t.scenario}`,t.index),addSteps(e,t)}))},formatComment=(e,t,r)=>{const s=e[r+1],n=e[r-1];let a=exists(s)?s:n;if(!a)return`${t}\n`;const i=t.split("#").pop();return`${Array(a.length-a.trimStart().length).join(" ")} # ${i}\n`},formatAssembled=e=>Array.from(e,((t,r)=>exists(t)?t.startsWith("#")?formatComment(e,t,r):`${t}\n`:"\n")).join("").trim(),assembleFeature=e=>eitherArr(e,[e]).map((e=>{let t=[];return!isObj(e)&&throwFeatureNotAnObj(e),addTags(t,e.tags),addMeta(t,e),addScenarios(t,e),formatAssembled(t)})),assemble={feature:assembleFeature};var _isInit=new WeakMap;class Parkin{constructor(e,t){_classPrivateFieldInitSpec(this,_isInit,{writable:!0,value:!1}),_defineProperty(this,"init",((e=noOpObj,t)=>{if(_classPrivateFieldGet(this,_isInit))return console.warn("This instance of parkin has already been initialized!");_classPrivateFieldSet(this,_isInit,!0),this.world=e,this.steps=new Steps(this.world),this.hooks=new Hooks(this.world),this.runner=new Runner(this.steps,this.hooks,this.world),this.run=this.runner.run,this.parse={feature:parseFeature.bind(this),definition:parseDefinition.bind(this)},this.assemble=assemble,this.paramTypes={register:registerParamType},isObj(t)&&this.registerSteps(t),this.steps.types.map((e=>{this[capitalize(e)]=(t,r,s)=>this.steps.register(`_${e}`,e,t,r,s)}))})),_defineProperty(this,"registerSteps",(e=>{Object.entries(e).map(((e,t)=>Object.entries(t).map(((t,r)=>this.steps[capitalize(e)](t,...eitherArr(r,[r]))))))})),isObj(e)&&this.init(e,t)}}const PKInstance=new Parkin;exports.PKInstance=PKInstance,exports.Parkin=Parkin;
