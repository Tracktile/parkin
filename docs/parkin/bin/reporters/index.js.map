{"version":3,"sources":["../../../src/bin/reporters/index.ts","../../../src/bin/reporters/cli/cli.ts","../../../node_modules/@keg-hub/jsutils/src/validation/validate.js","../../../node_modules/@keg-hub/jsutils/src/array/isArr.js","../../../node_modules/@keg-hub/jsutils/src/object/isObj.js","../../../node_modules/@keg-hub/jsutils/src/method/isFunc.js","../../../node_modules/@keg-hub/jsutils/src/string/isStr.js","../../../node_modules/@keg-hub/jsutils/src/number/equalsNaN.js","../../../node_modules/@keg-hub/jsutils/src/number/isNum.js","../../../node_modules/@keg-hub/jsutils/src/ext/typeOf.js","../../../node_modules/@keg-hub/jsutils/src/ext/isEmpty.js","../../../node_modules/@keg-hub/jsutils/src/ext/isSame.js","../../../node_modules/@keg-hub/jsutils/src/ext/isValidDate.js","../../../node_modules/@keg-hub/jsutils/src/boolean/isBool.js","../../../node_modules/@keg-hub/jsutils/src/string/toStr.js","../../../node_modules/@keg-hub/jsutils/src/boolean/isStrBool.js","../../../node_modules/@keg-hub/jsutils/src/boolean/convertToStrBool.js","../../../node_modules/@keg-hub/jsutils/src/boolean/toBool.js","../../../node_modules/@keg-hub/jsutils/src/collection/isColl.js","../../../node_modules/@keg-hub/jsutils/src/collection/isEmptyColl.js","../../../node_modules/@keg-hub/jsutils/src/collection/deepEqual.js","../../../node_modules/@keg-hub/jsutils/src/ext/exists.js","../../../node_modules/@keg-hub/jsutils/src/number/isNegative.js","../../../node_modules/@keg-hub/jsutils/src/number/isPositive.js","../../../node_modules/@keg-hub/jsutils/src/number/isFloat.js","../../../node_modules/@keg-hub/jsutils/src/number/isInt.js","../../../node_modules/@keg-hub/jsutils/src/object/hasOwn.js","../../../node_modules/@keg-hub/jsutils/src/object/isEntry.js","../../../node_modules/@keg-hub/jsutils/src/object/isArrMap.js","../../../node_modules/@keg-hub/jsutils/src/object/jsonEqual.js","../../../node_modules/@keg-hub/jsutils/src/string/isLowerCase.js","../../../node_modules/@keg-hub/jsutils/src/string/isUpperCase.js","../../../node_modules/@keg-hub/jsutils/src/string/isEmail.js","../../../node_modules/@keg-hub/jsutils/src/string/isIp.js","../../../node_modules/@keg-hub/jsutils/src/string/isPhone.js","../../../node_modules/@keg-hub/jsutils/src/string/isUrl.js","../../../node_modules/@keg-hub/jsutils/src/string/isUuid.js","../../../node_modules/@keg-hub/jsutils/src/string/isQuoted.js","../../../node_modules/@keg-hub/jsutils/src/url/isValidUrl.js","../../../node_modules/@keg-hub/jsutils/src/method/isOrderable.js","../../../node_modules/@keg-hub/jsutils/src/method/identity.js","../../../node_modules/@keg-hub/jsutils/src/method/match.js","../../../node_modules/@keg-hub/jsutils/src/dom/hasDomAccess.js","../../../node_modules/@keg-hub/jsutils/src/regex/isRegex.js","../../../node_modules/@keg-hub/jsutils/src/method/not.js","../../../node_modules/@keg-hub/jsutils/src/object/deepFreeze.js","../../../node_modules/@keg-hub/jsutils/src/ext/noOps.js","../../../node_modules/@keg-hub/jsutils/src/promise/promisify.js","../../../node_modules/@keg-hub/jsutils/src/promise/promisifyAll.js","../../../node_modules/@keg-hub/jsutils/src/promise/wait.js","../../../src/bin/reporters/cli/formatters.ts"],"sourcesContent":["export * from './cli'","import type { TFailedErrorResult, TRunResults } from '../../../types'\n\nimport { Logger } from '@keg-hub/cli-utils'\nimport {emptyObj} from '@keg-hub/jsutils'\n\nimport {\n  Tags,\n  Format,\n  FormatLine,\n  FormatError,\n  FormatChild,\n  FormatParent,\n  FormatErrors,\n} from './formatters'\n\n\nexport type TPrintResultOpts = {\n  failedOnly?:boolean\n  steps?:boolean\n  rules?:boolean\n  features?:boolean\n  errorOnly?:boolean\n  stepParents?:boolean\n  throwOnFailed?:boolean\n  exitWithError?:boolean\n}\n\nconst FailText = (text:string) => `${Logger.colors.red(`✘`)} ${Logger.colors.gray(`-`)} ${text}`\nconst PassText = (text:string) => `${Logger.colors.green(`✔`)} ${Logger.colors.gray(`-`)} ${text}`\n\nconst printResult = (\n  results:TRunResults,\n  opts:TPrintResultOpts=emptyObj\n) => {\n  const {\n    errorOnly,\n    failedOnly,\n    steps=true,\n    features=true,\n    stepParents=true,\n    exitWithError,\n    throwOnFailed\n  } = opts\n\n  let hasFailed:boolean\n  const output:string[] = []\n\n  results.forEach((result) => {\n\n    if((failedOnly || errorOnly) && result.passed) return\n \n    if(!hasFailed && result.failed) hasFailed = result.failed\n\n    if(features && (!errorOnly || !result.passed))\n      output.push(FormatParent(result.fullName, result.failed, result.failed))\n\n    result.describes.forEach(describe => {\n      if((failedOnly || errorOnly) && describe.passed) return\n\n      if(stepParents && (!errorOnly || !describe.passed))\n        output.push(FormatParent(describe.description, result.failed, describe.failed))\n\n      describe.tests.forEach(test => {\n        if((failedOnly || errorOnly) && test.passed) return\n\n        if(steps || !test.passed)\n          output.push(FormatChild(test.description, result.failed, test.failed))\n\n        test.failed && output.push(FormatErrors(test.failedExpectations as TFailedErrorResult[]))\n\n      })\n\n    })\n\n  })\n\n  if(!hasFailed){\n    if(!exitWithError) return output.length && Logger.log(output.join(``))\n    output.length && Logger.log(output.join(``))\n    Logger.empty()\n    Logger.log(PassText(`All features ${Logger.colors.green(`passed`)}\\n`))\n    process.exit(0)\n  }\n\n  if(exitWithError){\n    output.length && Logger.log(output.join(``))\n    Logger.empty()\n    Logger.log(FailText(`One or more Features ${Logger.colors.red(`failed`)}\\n`))\n    Logger.empty()\n    process.exit(1)\n  }\n\n  output.length && Logger.log(output.join(``))\n\n  if(throwOnFailed)\n    throw new Error(`One or more Features failed`)\n\n}\n\nexport const CLIReporter = {\n  tags: Tags,\n  fail: FailText,\n  pass: PassText,\n  results: printResult,\n  format: {\n    format: Format,\n    line: FormatLine,\n    error: FormatError,\n    child: FormatChild,\n    parent: FormatParent,\n    errors: FormatErrors,\n  }\n}\n","/** @module Validation */\n\n/**\n * @type {Object}\n */\nconst OPTIONS = {\n  SHOULD_LOG: true,\n  SHOULD_THROW: false,\n  LOG_PREFIX: null,\n}\n\n// if no default or custom validator set for an arg, just assert it is valid\nconst defaultValidator = () => true\n\n/**\n *  Validates each key-value entry in argObj using the validator functions in validators with matching keys.\n *  <br/>For any failures, validate will console.error the reason.\n *  @param {Object} argObj - object, where keys are the name of the argument to validate, and value is its value\n *  @param {Object} validators - object, where keys match the argument and values are predicate functions (return true/false and are passed the arg with the same key).\n *     - Use the `$default` key to define a default validator, which will validate any argument that doesn't have a custom validator defined.\n *  @param {Object} options - contains `logs`, `throws`, and `prefix` props. When a validation fails, it will throw an error if `throws` is true. Else it logs error if `logs` is true. `prefix` prepends a string to the error messages.\n *  @returns {Array} - An entry with two values [ success, results ].<br/>\n *     - success: { Boolean } that is true if all arguments passed their validators, false otherwise<br/>\n *     - results: {Object} that holds the validation results for each argument, keyed by the same keys as in argObj. For each\n *                result object, the properties are: { success, key, value, validator, reason }.\n *  @function\n *  @example\n *    const elements = {}\n *    const name = 'michael'\n *    const address = '12345 E. Street'\n *    const [ isValid, results ] = validate(\n *      { elements, name, address },\n *      { elements: isArr, $default: isStr }\n *    )\n *    console.log(isValid) // false\n *    console.log(results.elements.success) // false\n */\nexport const validate = (argObj, validators = {}, options = {}) => {\n  const {\n    logs = OPTIONS.SHOULD_LOG,\n    throws = OPTIONS.SHOULD_THROW,\n    prefix = OPTIONS.LOG_PREFIX,\n  } = options\n\n  const validationCaseEntries = Object.entries(argObj)\n\n  // validate each argument\n  const validationResults = validationCaseEntries.map(([ argName, argValue ]) =>\n    validateArgument(\n      argName,\n      argValue,\n      validators[argName] || validators.$default || defaultValidator\n    )\n  )\n\n  // reduce the argument validation results into a single object of form { success, cases }.\n  // success is true if all arguments passed their validators. Cases holds each argument's validation results.\n  const reduceCases = (total, next) =>\n    validationReducer(total, next, { logs, throws, prefix })\n  const { success, cases } = validationResults.reduce(reduceCases, {\n    success: true,\n    cases: {},\n  })\n\n  return [ success, cases ]\n}\n\n/**\n * If you need to configure validation properties globally, you can do so here. These are overridden by the validate options arguments,\n * if one is defined in validate().\n * @function\n * @param {Object} options\n * @param {Boolean} options.logs - indicates you want validate() to log errors when a case fails\n * @param {Boolean} options.throws - indicates validate() should throw an error when a case fails\n * @param {String} options.prefix - a prefix to any console error logs or to messages of errors thrown\n */\nvalidate.setOptions = ({ logs, throws, prefix }) => {\n  if (logs !== undefined) {\n    OPTIONS.SHOULD_LOG = logs\n  }\n  if (throws !== undefined) {\n    OPTIONS.SHOULD_THROW = throws\n  }\n  if (prefix !== undefined) {\n    OPTIONS.LOG_PREFIX = prefix\n  }\n}\n\n/**\n * Resets the global validation options to their defaults\n * @function\n */\nvalidate.resetOptions = () => {\n  OPTIONS.SHOULD_LOG = true\n  OPTIONS.SHOULD_THROW = false\n  OPTIONS.LOG_PREFIX = null\n}\n\n/**\n * Helper for `validate`. Validates a single value given a validator\n * @param {*} key\n * @param {*} value\n * @param {Function} validator\n * @returns {Object} of form { success, reason }\n * @ignore\n */\nconst validateArgument = (key, value, validator) => {\n  const success = validator(value)\n\n  // if validator is a named function, use its name. If it is an inline anonymous arrow function, its name\n  // matches the argument key and it has no useful/descriptive name, so just stringify it\n  const shouldStringifyValidator =\n    !validator.name || validator.name === key || validator.name === '$default'\n  const validatorString = shouldStringifyValidator\n    ? validator.toString()\n    : validator.name\n\n  const reason = success\n    ? null\n    : [\n        `Argument \"${key}\" with value `,\n        value,\n        ` failed validator: ${validatorString}.`,\n      ]\n\n  return { success, key, value, validator, reason }\n}\n\n/**\n * Helper for `validate`. Reduces validations into a single object of form { success, cases }\n * @param {*} finalResult\n * @param {*} nextValidation\n * @ignore\n */\nconst validationReducer = (\n  finalResult,\n  nextValidation,\n  { logs, throws, prefix }\n) => {\n  // handle the failure\n  !nextValidation.success && handleFailure(nextValidation, logs, throws, prefix)\n\n  return {\n    success: finalResult.success && nextValidation.success,\n    cases: {\n      ...finalResult.cases,\n      [nextValidation.key]: nextValidation,\n    },\n  }\n}\n\n/**\n * Handles a validation failure given validation options\n * @param {Object} validation\n * @param {Boolean} shouldLog\n * @param {Boolean} shouldThrow\n * @param {String} prefix - optional prefix to any error or console log\n * @ignore\n */\nconst handleFailure = (validation, shouldLog, shouldThrow, prefix) => {\n  // prepend the prefix if one is defined\n  const reason = prefix ? [ prefix, ...validation.reason ] : validation.reason\n\n  if (shouldThrow) throw new Error(reason.join())\n\n  if (shouldLog) console.error(...reason)\n}\n","/** @module Array */\n\n/**\n * Checks if passed in value is an array.\n * @function\n * @example\n * isArr([1,2,3])\n * // Returns true\n * @param {any} value - value to be check if is an array\n * @return {Boolean} - T/F value is an array\n */\nexport const isArr = value => Array.isArray(value)\n","/** @module Object */\n\n/**\n * Checks if data is an object and not an array.\n * @function\n * @param {Object} obj - data to check\n * @returns {Boolean}\n */\nexport const isObj = obj =>\n  typeof obj === 'object' && !Array.isArray(obj) && obj !== null\n","/** @module Function */\n\n/**\n * Check if the passed in item is a function.\n * @example\n * isFunc(() => {})\n * // Returns true\n * @example\n * isFunc('bar')\n * // Returns false\n * @function\n * @param {*} test\n * @return {Boolean} is a function\n */\nexport const isFunc = func => typeof func === 'function'\n","/** @module String */\n\n/**\n * Check if passed in value is a string.\n * @function\n * @param {*} str - param to check if type is a string\n * @return {Boolean} - True if it's a string\n */\nexport const isStr = str => typeof str === 'string'\n","/** @module Number */\n\n/**\n * Checks if a value is NaN.\n * @example\n * equalsNaN(NaN)\n * // Returns true\n * @example\n * equalsNaN(1)\n * // Returns false\n * @example\n * equalsNaN('')\n * // Returns false\n * @function\n * @param {Number} val - value to check if is NaN\n * @return {Boolean} T/F - if value is a number\n */\nexport const equalsNaN = val => typeof val === 'number' && val != val\n","/** @module Number */\n\nimport { equalsNaN } from './equalsNaN'\n\n/**\n * Checks is value is a number.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt(NaN)\n * // Returns false\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {*} val - value to check if is a number\n * @return {Boolean} T/F - if value is a number\n */\nexport const isNum = val => typeof val === 'number' && !equalsNaN(val)\n","/** @module Extra */\n\n/**\n * Gets the type of the passed in val.\n * @example\n * typeOf(1)\n * // Returns Number\n * @example\n * typeOf('')\n * // Returns String\n * @function\n * @param {*} val - value to get type for\n * @return {String} type of the value\n */\nexport const typeOf = val => Object.prototype.toString.call(val).slice(8, -1)\n","/** @module Extra */\n\nimport { isObj } from '../object/isObj'\nimport { isArr } from '../array/isArr'\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\n\n/**\n * Checks if the value is empty.\n * @example\n * isEmpty('')\n * // Returns true\n * @example\n * isEmpty({})\n * // Returns true\n * @example\n * isEmpty([ 1 ])\n * // Returns false\n * @function\n * @param {*} val - value to check\n * @return {Boolean} if the value is empty\n */\nexport const isEmpty = val =>\n  isObj(val)\n    ? Object.keys(val).length === 0\n    : isArr(val)\n      ? val.length === 0\n      : isStr(val)\n        ? val.trim().length === 0\n        : isNum(val)\n          ? val < 1\n          : false\n","/** @module Extra */\n\n/**\n * Checks if the passed in values are exactly the same.\n * @example\n * isSame(1, 1)\n * // Returns true\n * @function\n * @param {*} val1 - value to compare\n * @param {*} val2 - value to compare\n * @return {Boolean} is the values are the same\n */\nexport const isSame = (val1, val2) =>\n  val1 === val2\n    ? val1 !== 0 || 1 / val1 === 1 / val2\n    : val1 !== val1 && val2 !== val2\n","/** @module Extra */\n\n/**\n * Checks is passed in date is a valid date.\n * @example\n * isValidDate(new Date())\n * // Returns true\n * @example\n * isValidDate(new Date().toString())\n * // Returns true\n * @example\n * isValidDate('12345678')\n * // Returns false\n * @function\n * @param { Date|String } date - value to check\n * @return {Boolean} T/F - if passed in date is a valid date\n */\nexport const isValidDate = date =>\n  !isNaN(((date instanceof Date && date) || new Date(date)).getTime())\n","/** @module Boolean */\n\n/**\n * Checks is value is a boolean.\n * @function\n * @example\n * isBool([1,2,3])\n * // Returns false\n * @example\n * isBool(true)\n * // Returns true\n * @param {*} val - value to check if is a number\n * @return {Boolean} True if val is a boolean\n */\nexport const isBool = val => typeof val === 'boolean'\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts a passed in value to a string.\n * @function\n * @param {*} val - value to be converted\n * @return {String} - value converted into a string\n */\nexport const toStr = val =>\n  val === null || val === undefined\n    ? ''\n    : isStr(val)\n      ? val\n      : JSON.stringify(val)\n","/** @module Boolean */\n\n/**\n * Checks is value is a boolean as a string.\n * @function\n * @example\n * isStrBool(\"true\")\n * // Returns true\n * @example\n * isStrBool(true)\n * // Returns false\n * @param {*} val - value to check if boolean as a string\n * @return {Boolean} True if val is a string boolean\n */\nexport const isStrBool = val => val === 'false' || val === 'true'\n","/** @module Boolean */\n\nimport { toStr } from '../string/toStr'\nimport { isBool } from './isBool'\n\n/**\n * Converts a value to a boolean as a string.\n * @function\n * @example\n * convertToStrBool(true)\n * // Returns 'true'\n * @param {*} val - value to convert to string boolean\n * @return {String} 'true' || 'false' based on passed in value\n */\nexport const convertToStrBool = val =>\n  isBool(val)\n    ? toStr(val)\n    : !val || val === 'false' || val === '0'\n        ? 'false'\n        : 'true'\n","/** @module Boolean */\n\nimport { isStrBool } from './isStrBool'\nimport { convertToStrBool } from './convertToStrBool'\n\n/**\n * Converts a value to a boolean.\n * @function\n * @example\n * toBool(null)\n * // Returns false\n * @example\n * toBool('false')\n * // Returns false\n * @example\n * toBool('true')\n * // Returns true\n * @param {*} val - value to convert\n * @return {Boolean} true or false based on passed in value.\n */\nexport const toBool = val =>\n  isStrBool(val) ? val === 'true' : convertToStrBool(val) === 'true'\n","/** @module Collection */\n\n/**\n * Checks if the value is a collection ( object || array ).\n * @example\n * isColl([1,2,3])\n * // Returns true\n * @example\n * isColl({ foo: 'bar' })\n * // Returns true\n * @example\n * isColl(null)\n * // Returns false\n * @function\n * @param {*} val - Value to check\n * @return {Boolean} True if the value is a collection (Object || Array)\n */\nexport const isColl = val => typeof val === 'object' && val !== null\n","/** @module Collection */\n\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Checks if passed in obj || array is empty.\n * @example\n * isEmptyColl({})\n * // Returns true\n * @example\n * isEmptyColl({ foo: 'bar' })\n * // Returns false\n * @example\n * isEmptyColl([])\n * // Returns true\n * @function\n * @param {*} obj - Object to check if empty\n * @return {Boolean} - True if the passed in collection is empty\n */\nexport const isEmptyColl = obj =>\n  isArr(obj)\n    ? obj.length === 0\n    : isColl(obj) && Object.getOwnPropertyNames(obj).length === 0\n","/** @module Collection */\n\n// Cache the prototype methods for faster access\nconst isArray = Array.isArray\nconst keyList = Object.keys\nconst hasProp = Object.prototype.hasOwnProperty\n\n/**\n * Recursively checks if two collections are equal\n * <br/>Faster the JSON.stringify checks\n * <br/>See https://jsperf.com/fast-deep-equal-vs-json-stringify\n * @example\n * const test = { foo: [ { bar: 'baz' } ] }\n * const test2 = { foo: [ { bar: 'baz' } ] }\n * console.log(test === test2)) // prints false\n * deepEqual(test, test2) // returns true\n * @example\n * // Works with arrays too\n * deepClone([ [ [ 0 ] ] ], [ [ [ 0 ] ] ]) // returns true\n * @function\n * @param {Object|Array} a - Object to check\n * @param {Object|Array} b - Object to check against\n */\nexport const deepEqual = (a, b) => {\n  if (a === b) return true\n\n  if (!a || !b || typeof a != 'object' || typeof b != 'object')\n    return a !== a && b !== b\n\n  const arrA = isArray(a)\n  const arrB = isArray(b)\n  let i\n  let length\n  let key\n\n  // If both are arrays\n  if (arrA && arrB) {\n    length = a.length\n    // If unequal length, then not equal\n    if (length != b.length) return false\n    // Loop the arrays and check the contents of both\n    for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false\n\n    return true\n  }\n\n  // If on is an array and the other is not, then return false\n  if (arrA != arrB) return false\n\n  // Validate date objects\n  const dateA = a instanceof Date\n  const dateB = b instanceof Date\n  if (dateA != dateB) return false\n  if (dateA && dateB) return a.getTime() == b.getTime()\n\n  // Validate RegExp objects\n  const regexpA = a instanceof RegExp\n  const regexpB = b instanceof RegExp\n  if (regexpA != regexpB) return false\n  if (regexpA && regexpB) return a.toString() == b.toString()\n\n  // Cache the keys and length for faster iteration\n  const keys = keyList(a)\n  length = keys.length\n\n  // If unequal key length then return false\n  if (length !== keyList(b).length) return false\n\n  // Ensure both objects have the same keys\n  for (i = length; i-- !== 0;) if (!hasProp.call(b, keys[i])) return false\n\n  // Check the value of the object keys\n  for (i = length; i-- !== 0;) {\n    key = keys[i]\n    if (!deepEqual(a[key], b[key])) return false\n  }\n\n  return true\n}\n","/** @module Extra */\n\n/**\n * Checks if a value exists. NOT undefined || null\n * @function\n * @example\n * exists(0)\n * // Returns true\n * @example\n * exists(null)\n * // Returns false\n * exists('')\n * // Returns true\n * exists(NaN)\n * // Returns false\n * @param {*} value - Item to check if exists\n *\n * @returns {Boolean} - If the item exists or not\n */\nexport const exists = value =>\n  value === value && value !== undefined && value !== null\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * @function\n * @param {*} x\n * @returns { boolean } true if x is a negative number\n * @example isNegative(-1) // true\n * @example isNegative(0) // false\n */\nexport const isNegative = x => isNum(x) && x < 0\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * @function\n * @param {*} x\n * @returns { boolean } true if x is a positive number\n * @example isPositive(0) // false\n * @example isPositive(1) // true\n */\nexport const isPositive = x => isNum(x) && x > 0\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if a number is a Float.\n * @example\n * isFloat(1.23)\n * // Returns true\n * @example\n * isFloat('1.2')\n * // Returns false ( because it's a string )\n * @function\n * @param {Number} num - value to check\n * @return {Boolean} true or false - value is an Float\n */\nexport const isFloat = val => isNum(val) && val % 1 !== 0\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if a number is an integer.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {Number} num - value to check\n * @return {Boolean} true or false - value is an Int\n */\nexport const isInt = val => isNum(val) && val % 1 === 0\n","/** @module Object */\n\n/**\n * Checks if prop exists on the object.\n * @function\n * @param {Object} obj - data to check\n * @param {String} prop - prop to check for\n * @returns {Boolean} T/F if the prop exists\n */\nexport const hasOwn = (obj, prop) =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","/** @module Object */\n\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\nimport { isArr } from '../array/isArr'\n\n/**\n * Checks if the input is a valid entry - a 2-element array, like what Object.entries produces.\n * Expects the first element in the entry to be either a string or a number.\n * @function\n * @example isEntry([1, 2]) // true\n * @example isEntry([\"id\", 87]) // true\n * @example isEntry([new Date(), 2]) // false, first element not string or number\n * @example isEntry([1, 2, 3]) // false, too many elements\n * @param {*} maybeEntry - Item to check if it's an entry\n *\n * @returns {Boolean} - True if it is an entry, false otherwise\n */\nexport const isEntry = maybeEntry =>\n  isArr(maybeEntry) &&\n  maybeEntry.length === 2 &&\n  (isNum(maybeEntry[0]) || isStr(maybeEntry[0]))\n","/** @module Object */\n\nimport { isObj } from './isObj'\nimport { isArr } from '../array/isArr'\nimport { toBool } from '../boolean/toBool'\n\n/**\n * Returns true if the input is an object and every value is an array\n * @function\n * @param {Object|*} obj - data to check\n * @return {Boolean} - true if input is an array map\n */\nexport const isArrMap = obj => {\n  if (!isObj(obj)) return false\n  const values = Object.values(obj)\n  return toBool(values.length && values.every(isArr))\n}\n","/** @module Object */\n\n/**\n * Compares two objects by converting to JSON, and checking string equality.\n * @function\n * @param { object | array } one - object to compare with param two\n * @param { object | array } two - object to compare with param one\n * @return {Boolean} status of equality\n */\nexport const jsonEqual = (one, two) => {\n  try {\n    return JSON.stringify(one) === JSON.stringify(two)\n  }\n  catch (e) {\n    return false\n  }\n}\n","/** @module String */\n\n/**\n * Checks if a string is all lowercase letters\n * @function\n * @param {String} str - String to check if it's lowercase\n * @returns {Boolean} - True if str is lowercase\n */\nexport const isLowerCase = str => str === str.toLowerCase()\n","/** @module String */\n\n/**\n * Checks if a string is all capital letters\n * @function\n * @param {String} str - String to check if it's uppercase\n * @returns {Boolean} - True if str is uppercase\n */\nexport const isUpperCase = str => str === str.toUpperCase()\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a email.\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's a email\n */\nexport const isEmail = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\nconst regex = {\n  ipv4: /^(?:(?:\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(?:\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$/,\n  ipv6: /^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i,\n}\n\n/**\n * Check if string is an Ip address, both Ip4 and Ip6\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's an Ip address\n */\nexport const isIp = str => {\n  if (!str || !isStr(str)) return false\n\n  const isIp4 = Boolean(regex.ipv4.test(str))\n  return isIp4 || Boolean(regex.ipv6.test(str))\n}\n\n/**\n * Check if string is an IP4 address\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's an IP4 address\n */\nexport const isIp4 = str => {\n  if (!str || !isStr(str)) return false\n\n  return Boolean(regex.ipv4.test(str))\n}\n\n/**\n * Check if string is an IP6 address\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's an IP6 address\n */\nexport const isIp6 = str => {\n  if (!str || !isStr(str)) return false\n\n  return Boolean(regex.ipv6.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a phone number.\n * @function\n * @param {String} str - string to check\n * @return {Boolean} - True if str is a phone number\n */\nexport const isPhone = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/im\n  return Boolean(regex.test(str)) && str.replace(/\\D/g, '').length < 11\n}\n","/** @module String */\n\n/**\n * Check if string is a url.\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's a url\n */\nexport const isUrl = str => {\n  const regex =\n    /^(?:(?:https?|ftp):\\/\\/)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a uuid.\n * @function\n * @param {String} str - string to check\n * @return {Boolean} - if it's a uuid\n */\nexport const isUuid = str => {\n  if (!str || !isStr(str)) return false\n  const regex =\n    /^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\nconst quoteSymbols = [ '\"', \"'\" ]\n\n/**\n * Checks if the string contains quoted text\n * @function\n * @param {String} str - string to check\n * @param {Array<string>?} [quotes] - optional array of valid quote strings to check with. Defaults to single and double quote characters.\n * @return {Boolean} true if `str` is a quoted string\n * @example\n * isQuoted('foo') // false\n * @example\n * isQuoted('\"foo\"') // true\n */\nexport const isQuoted = (str, quotes = quoteSymbols) => {\n  return (\n    isStr(str) &&\n    quotes.some(quote => str.startsWith(quote) && str.endsWith(quote))\n  )\n}\n","/** @module Url */\n\n/**\n * Checks if the given string is a valid URL\n * Must begin with ftp/http/https\n * @param {String} str - any string to check if it's a valid url\n * @function\n * @returns {Boolean}\n */\nexport const isValidUrl = str => {\n  var regexp =\n    /(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-/]))?/\n\n  return regexp.test(str)\n}\n","/** @module Function */\n\nimport { isStr } from '../string'\nimport { isBool } from '../boolean'\nimport { isNum } from '../number'\n\n/**\n * Checks if param is an orderable primitive\n * @function\n * @param {*} x\n * @returns {bool} - true if x is a comparable primitive\n */\nexport const isOrderable = x => isStr(x) || isNum(x) || isBool(x)\n","/** @module Function */\n\n/**\n * A function that simply returns its input\n * @function\n * @param {*} x\n * @returns {*} the input\n */\nexport const identity = x => x\n","/** @module Function */\n\nimport { isArr } from '../array/isArr'\nimport { typeOf } from '../ext/typeOf'\nimport { isFunc } from './isFunc'\n\n/**\n * Pattern matching function. Iterates through the entries,\n * <br/>which have the form [ check value or predicate, return value ], and\n * <br/>when it encounters an entry whose check value matches the matchArg\n * <br/>(or the predicate returns true when passed the matchArg), it returns\n * <br/>the return value of that entry.\n *\n * For the default case: use [ match.default, <your default value> ]\n * @function\n *\n * @param {*} matchArg - the argument to match against the cases\n * @param {Array} entries - the cases to match against the matchArg\n * @returns {*} - the return value of the first entry with a matching check value, else null\n *\n * @example\n * const value = 1\n * match(value,\n *  [ 1, \"hello\" ],\n *  [ x => x > 2, \"greater\" ]\n *  [ match.default, \"defaulted\"]\n * )\n * => returns \"hello\"\n *\n * @example\n * const value = 3\n * match(value,\n *  [ 1, \"hello\" ],\n *  [ x => x > 2, \"greater\" ]\n * )\n * => returns \"greater\"\n *\n * @example\n * // react reducer:\n *function todoReducer(state, action) {\n *   const reducer = match(action.type,\n *       [ 'ADD-TODO', addTodo ],\n *       [ 'REMOVE-TODO', removeTodo ],\n *       [ 'UPDATE-TODO', updateTodo ],\n *       [ match.default, state ]\n *   )\n *\n *   return reducer(state, action)\n *}\n */\nexport const match = (matchArg, ...args) => {\n  if (!args.length) return null\n\n  // check all cases and return a value if a match is found\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(\n        `Matching case must be an entry (a 2-element array). Found: ${typeOf(\n          entry\n        )}`,\n        entry\n      )\n      break\n    }\n    const [ caseValueOrPredicate, valueOnMatch ] = entry\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg))\n      return valueOnMatch\n    if (caseValueOrPredicate === matchArg) return valueOnMatch\n  }\n\n  return null\n}\n\n/**\n * The default case function you can use with match. Just returns true so the case value can be used.\n * @function\n * @example\n * match(foo\n *    [ 100, 'a' ],\n *    [ 200, 'b' ],\n *    [ match.default, 'default value' ]\n * )\n */\nmatch.default = () => true\n","/** @module Dom */\n\n/**\n * Checks if there is access to the dom\n * @function\n * @example\n * // In Browser\n * hasDomAccess() === true\n * // In Node\n * hasDomAccess() === false\n * @return {Boolean} True if executed in a browser\n */\nexport const hasDomAccess = () => {\n  try {\n    return !!(\n      typeof window !== 'undefined' &&\n      window.document &&\n      window.document.createElement\n    )\n  }\n  catch (error) {\n    return false\n  }\n}\n\nexport { hasDomAccess as isDom }\n","/** @module RegEx */\n\n/**\n * Checks if value is an instance of regex\n * @function\n * @param {*} val\n * @return {Boolean} true if val is an instance of RegExp\n * @example\n * isRegex(new RegExp('a')) // true\n * isRegex(/a/) // true\n * isRegex('a') // false\n */\nexport const isRegex = val => Boolean(val && val instanceof RegExp)\n","/** @module Function */\n\nimport { isBool } from '../boolean/isBool'\nimport { isStrBool } from '../boolean/isStrBool'\n\nimport { isColl } from '../collection/isColl'\nimport { isEmptyColl } from '../collection/isEmptyColl'\nimport { deepEqual } from '../collection/deepEqual'\n\nimport { isDom } from '../dom/hasDomAccess'\n\nimport { exists } from '../ext/exists'\nimport { isEmpty } from '../ext/isEmpty'\nimport { isSame } from '../ext/isSame'\nimport { isValidDate } from '../ext/isValidDate'\n\nimport { isFunc } from './isFunc'\nimport { identity } from './identity'\nimport { isOrderable } from './isOrderable'\n\nimport { equalsNaN } from '../number/equalsNaN'\nimport { isFloat } from '../number/isFloat'\nimport { isInt } from '../number/isInt'\nimport { isNum } from '../number/isNum'\nimport { isNegative } from '../number/isNegative'\nimport { isPositive } from '../number/isPositive'\n\nimport { hasOwn } from '../object/hasOwn'\nimport { isEntry } from '../object/isEntry'\nimport { isArrMap } from '../object/isArrMap'\nimport { isObj } from '../object/isObj'\nimport { jsonEqual } from '../object/jsonEqual'\n\nimport { isRegex } from '../regex/isRegex'\n\nimport { isEmail } from '../string/isEmail'\nimport { isIp } from '../string/isIp'\nimport { isLowerCase } from '../string/isLowerCase'\nimport { isPhone } from '../string/isPhone'\nimport { isQuoted } from '../string/isQuoted'\nimport { isStr } from '../string/isStr'\nimport { isUpperCase } from '../string/isUpperCase'\nimport { isUrl } from '../string/isUrl'\nimport { isUuid } from '../string/isUuid'\n\nimport { isValidUrl } from '../url/isValidUrl'\n\n/**\n * When called, it calls original function, then returns inverse of the functions result\n * <br/>Should be used with functions that return a boolean\n * @function\n * @param {Function} func - Function call and invert its response\n *\n * @returns {Function} - Calls the passed in function then returns True if the passed in function returns falsy, otherwise false\n */\nexport const not = func => {\n  return (...args) => !func.apply(null, args)\n}\n\nnot.bool = not(isBool)\nnot.strBool = not(isStrBool)\nnot.coll = not(isColl)\nnot.deepEqual = not(deepEqual)\nnot.emptyColl = not(isEmptyColl)\nnot.dom = not(isDom)\nnot.exists = not(exists)\nnot.empty = not(isEmpty)\nnot.same = not(isSame)\nnot.validDate = not(isValidDate)\nnot.func = not(isFunc)\nnot.identity = not(identity)\nnot.orderable = not(isOrderable)\nnot.equalsNaN = not(equalsNaN)\nnot.float = not(isFloat)\nnot.int = not(isInt)\nnot.num = not(isNum)\nnot.negative = not(isNegative)\nnot.positive = not(isPositive)\nnot.hasOwn = not(hasOwn)\nnot.entry = not(isEntry)\nnot.arrMap = not(isArrMap)\nnot.obj = not(isObj)\nnot.jsonEqual = not(jsonEqual)\nnot.regex = not(isRegex)\nnot.email = not(isEmail)\nnot.ip = not(isIp)\nnot.lowerCase = not(isLowerCase)\nnot.phone = not(isPhone)\nnot.quoted = not(isQuoted)\nnot.str = not(isStr)\nnot.upperCase = not(isUpperCase)\nnot.url = not(isUrl)\nnot.uuid = not(isUuid)\nnot.validUrl = not(isValidUrl)\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Recursively freezes and object.\n * @function\n * @param {Object} obj\n * @return {Object} - frozen Object\n */\nexport const deepFreeze = obj => {\n  Object.freeze(obj)\n  Object.getOwnPropertyNames(obj).map(prop => {\n    obj.hasOwnProperty(prop) &&\n      obj[prop] !== null &&\n      (typeof obj[prop] === 'object' || isFunc(obj[prop])) &&\n      !Object.isFrozen(obj[prop]) &&\n      deepFreeze(obj[prop])\n  })\n\n  return obj\n}\n","/** @module Extra */\n\nimport { deepFreeze } from '../object/deepFreeze'\n\n/**\n * Reuseable empty, frozen object\n * @object\n * @type {Object}\n */\nexport const noOpObj = Object.freeze({})\n\n/**\n * Reuseable empty, frozen object\n * @object\n * @type {Object}\n */\nexport const emptyObj = noOpObj\n\n/**\n * Reusable frozen object that contains a `content` object. Useful\n * @object\n * for themes that rely on the content key.\n * @type {Object}\n */\nexport const noPropObj = deepFreeze({ content: {} })\n\n/**\n * Reusable, empty frozen array\n * @array\n * @type {Array}\n */\nexport const noPropArr = deepFreeze([])\n\n/**\n * Reusable, empty frozen array.\n * Renamed for consistency\n * @array\n * @type {Array}\n */\nexport const noOpArr = noPropArr\n\n/**\n * Reusable, empty frozen array.\n * Renamed for legibility\n * @array\n * @type {Array}\n */\nexport const emptyArr = noPropArr\n","/** @module Promise */\n\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Converts a standard callback method into Promise\n * @param {Function} method - Function to convert into a promise\n * @function\n *\n * @return {Promise<Function>} - Passed in method converted into a promise\n */\nexport const promisify = method => {\n  if (!isFunc(method)) throw `Argument must be a function`\n\n  return (...args) => {\n    return new Promise((res, rej) => {\n      // If the last arg is not a function, just return the resolved method\n      if (!isFunc(args[args.length - 1])) return res(method(...args))\n\n      // Remove the callback method\n      args.pop()\n      // Replace it with the promise resolve / reject\n      args.push((...cbData) => {\n        // If the cbData first arg is not falsy, then reject the promise\n        // Otherwise resolve it\n        return cbData && cbData[0] ? rej(...cbData) : res(...cbData)\n      })\n\n      // Call the method, and return it\n      return method(...args)\n    })\n  }\n}\n","/** @module Promise */\n\nimport { isObj } from '../object/isObj'\nimport { isFunc } from '../method/isFunc'\nimport { promisify } from './promisify'\n\n/**\n * Creates an array of Object default properties not to convert into promises\n * @ignore\n */\nconst defObjProps = Array.from([\n  'caller',\n  'callee',\n  'arguments',\n  'apply',\n  'bind',\n  'call',\n  'toString',\n  '__proto__',\n  '__defineGetter__',\n  '__defineSetter__',\n  'hasOwnProperty',\n  '__lookupGetter__',\n  '__lookupSetter__',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'valueOf',\n  'toLocaleString',\n])\n  .concat(Object.getOwnPropertyNames(Object.prototype))\n  .reduce((map, functionName) => {\n    map[functionName] = true\n    return map\n  }, {})\n\n/**\n * Loops an object and looks for any methods that belong to the object, then add an Async version\n * @param {Object} object\n * @return {Object} - object with Async methods added\n * @private\n */\nconst addAsync = object => {\n  if (!object.__IS_PROMISIFIED__) {\n    for (const prop of Object.getOwnPropertyNames(object)) {\n      const isAsync = prop.indexOf('Async') !== -1 || object[`${prop}Async`]\n      if (isAsync || defObjProps[prop]) continue\n\n      if (isFunc(object[prop])) object[`${prop}Async`] = promisify(object[prop])\n      else {\n        const getValue = Object.getOwnPropertyDescriptor(object, prop).get\n        if (isFunc(getValue)) object[`${prop}Async`] = promisify(getValue)\n      }\n    }\n    object.__IS_PROMISIFIED__ = true\n  }\n\n  return object\n}\n\n/**\n * Converts Objects method properties into promiseAsync. allow using promisifyAll\n * @function\n * @param {Object} object\n * @return {Object} - promisified object\n */\nexport const promisifyAll = object => {\n  if (!isObj(object)) return object\n\n  addAsync(object)\n  const proto = Object.getPrototypeOf(object)\n\n  proto && Object.getPrototypeOf(proto) !== null && addAsync(proto)\n\n  return object\n}\n","/** @module Promise */\n\n'use strict'\n\n/**\n * Stops execution for a given amount of time\n * @function\n * @param {Number} time - Amount of time to wait\n * @return { void }\n */\nexport const wait = time =>\n  new Promise(res => setTimeout(() => res(true), time))\n","import type { TFailedErrorResult, TRunResult } from '../../../types'\n\nimport { Logger } from '@keg-hub/cli-utils'\n\nexport type TFormatLine = {\n  type:string\n  text:string\n  failed?:boolean\n  isFailed?:boolean\n  isParent?:boolean\n  isFeature?:boolean\n}\n\nconst Clrs = Logger.colors\nconst FailTag = `${Clrs.colorMap.red}✘`\nconst PassTag = `${Clrs.colorMap.green}✔`\nconst WarnTag = `${Clrs.colorMap.yellow}○`\nconst FPassTag = `\\x1b[42m\\x1b[30m PASS \\x1b[0m`\nconst FFailTag = `\\x1b[41m\\x1b[30m FAIL \\x1b[0m`\nconst FWarnTag = `\\x1b[43m\\x1b[30m WARN \\x1b[0m`\n\nexport const Tags = {\n  root: {\n    fail: FFailTag,\n    pass: FPassTag,\n    warn: FWarnTag,\n  },\n  child: {\n    fail: FailTag,\n    pass: PassTag,\n    warn: WarnTag,\n  }\n}\n\nconst DimText = (text:string) => (`${Clrs.colorMap.dim}${text}`)\n\nconst ColorMap = {\n  Feature: {\n    text: Clrs.colorMap.gray,\n    type: Clrs.colorMap.yellow,\n  },\n  Rule: {\n    text: Clrs.colorMap.gray,\n    type: Clrs.colorMap.blue,\n  },\n  Parent: {\n    text: Clrs.colorMap.gray,\n    type: Clrs.colorMap.magenta,\n  },\n  Step: {\n    text: Clrs.colorMap.gray,\n    type: Clrs.colorMap.cyan,\n  },\n  Error: {\n    text: Clrs.colorMap.white,\n    type: Clrs.colorMap.red,\n  }\n}\n\nexport const FormatLine = (args:TFormatLine) => {\n  const {\n    type,\n    text,\n    failed,\n    isParent,\n    isFailed,\n    isFeature,\n  } = args\n\n  const sep = isParent ? ` ${Clrs.colorMap.white}> ` : ` `\n  const [PTag, FTag, WTag] = isFeature\n    ? [FPassTag, FFailTag, FWarnTag]\n    : [PassTag, FailTag, WarnTag]\n\n  const tag = !failed ? PTag : isFailed ? FTag : WTag\n  const colorType = ColorMap[type as keyof typeof ColorMap]\n\n  const colors = failed && isFailed\n    ? ColorMap.Error\n    : colorType\n      ? colorType\n      : isParent\n        ? ColorMap.Parent\n        : ColorMap.Step\n\n  \n  const line = `${tag} ${colors.type}${type}${sep}${colors.text}${text}${Clrs.colorMap.reset}`\n\n  /** Don't dim the text if not failed || this line is the line that failed */\n  return (isFailed || !failed) ? line : DimText(line)\n\n}\n\nexport const FormatParent = (text:string, failed?:boolean, isFailed?:boolean) => {\n  const [first, description] = text.split(`>`)\n  const type = first.trim()\n  const isFeature = type.startsWith(`Feature`)\n\n  const line = FormatLine({\n    type,\n    failed,\n    isFailed,\n    isParent: true,\n    isFeature: type.startsWith(`Feature`),\n    text: (description || ``)?.trim?.(),\n  })\n\n  return isFeature ? `\\n${line}\\n` : `  ${line}\\n`\n}\n\nexport const FormatChild = (text:string, failed?:boolean, isFailed?:boolean) => {\n  const [type, ...rest] = text.split(` `)\n  const line = FormatLine({\n    failed,\n    isFailed,\n    isParent: false,\n    type: type.trim(),\n    text: (rest.join(` `) || ``)?.trim?.(),\n  })\n\n  return `    ${line}\\n`\n}\n\nexport const FormatError = (failed:TFailedErrorResult) => {\n  const output = []\n  const space = `      `\n\n  const { fullName, description, error } = failed\n  const message = error ? error.stack : `${fullName}\\n${description}`\n\n  const [first, ...lines] = message.split(`\\n`)\n  output.push(`\\n${space}${Clrs.red(first)}\\n`)\n  output.push(Clrs.white(lines.map(line => `${space}${line}`).join(`\\n`)))\n  output.push(`\\n\\n`)\n\n  return output.join(``)\n}\n\nexport const FormatErrors = (failedExps:TFailedErrorResult[]) => {\n  return failedExps.map(failed => FormatError(failed)).join(``)\n}\n\n\nexport const Format = (text:string, failed?:boolean, isFailed?:boolean) => {\n  return text.includes(`>`)\n    ? FormatParent(text, failed, isFailed)\n    : FormatChild(text, failed, isFailed)\n}\n"],"mappings":"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","names":["import_cli_utils","OPTIONS","SHOULD_LOG","SHOULD_THROW","LOG_PREFIX","defaultValidator","validate","argObj","validators","options","logs","throws","prefix","validationCaseEntries","Object","entries","validationResults","map","argName","argValue","validateArgument","$default","reduceCases","total","next","validationReducer","success","cases","reduce","setOptions","undefined","resetOptions","key","value","validator","shouldStringifyValidator","name","validatorString","toString","reason","finalResult","nextValidation","handleFailure","validation","shouldLog","shouldThrow","Error","join","console","error","isArr","value","Array","isArray","isObj","obj","Array","isArray","isFunc","func","isStr","str","equalsNaN","val","isNum","typeOf","val","Object","prototype","toString","call","slice","isEmpty","isObj","keys","length","isArr","isStr","trim","isNum","isSame","val1","val2","isValidDate","date","isNaN","Date","getTime","isBool","val","toStr","val","undefined","isStr","JSON","stringify","isStrBool","val","convertToStrBool","isBool","toStr","toBool","isColl","val","isEmptyColl","obj","isArr","length","isColl","Object","getOwnPropertyNames","isArray","Array","keyList","keys","hasProp","prototype","hasOwnProperty","deepEqual","a","b","arrA","arrB","i","key","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","call","exists","value","undefined","isNegative","x","isNum","isPositive","isFloat","val","isInt","hasOwn","obj","prop","Object","prototype","hasOwnProperty","call","isEntry","maybeEntry","isArr","length","isNum","isStr","isArrMap","isObj","values","toBool","every","jsonEqual","one","two","JSON","stringify","e","isLowerCase","str","toLowerCase","isUpperCase","toUpperCase","isEmail","isStr","regex","Boolean","test","ipv4","ipv6","isIp","isIp4","isPhone","str","isStr","regex","Boolean","test","replace","length","isUrl","isUuid","quoteSymbols","isQuoted","quotes","some","quote","startsWith","endsWith","isValidUrl","str","regexp","test","isOrderable","x","isStr","isNum","isBool","identity","match","matchArg","args","length","entry","isArr","console","error","typeOf","caseValueOrPredicate","valueOnMatch","isFunc","default","hasDomAccess","window","document","createElement","isRegex","val","Boolean","RegExp","not","func","apply","bool","strBool","isStrBool","coll","isColl","deepEqual","emptyColl","isEmptyColl","dom","isDom","exists","empty","isEmpty","same","isSame","validDate","isValidDate","orderable","equalsNaN","float","isFloat","int","isInt","num","negative","isNegative","positive","isPositive","hasOwn","isEntry","arrMap","isArrMap","obj","isObj","jsonEqual","regex","email","isEmail","ip","isIp","lowerCase","isLowerCase","phone","isPhone","quoted","isQuoted","str","upperCase","isUpperCase","url","isUrl","uuid","isUuid","validUrl","isValidUrl","deepFreeze","obj","Object","freeze","getOwnPropertyNames","map","prop","hasOwnProperty","isFunc","isFrozen","noOpObj","emptyObj","noPropObj","content","noPropArr","defObjProps","Array","from","concat","Object","getOwnPropertyNames","prototype","reduce","map","functionName"]}