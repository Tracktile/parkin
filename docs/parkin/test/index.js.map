{"version":3,"sources":["../../src/test/index.ts","../../node_modules/@keg-hub/jsutils/src/validation/validate.js","../../node_modules/@keg-hub/jsutils/src/array/isArr.js","../../node_modules/@keg-hub/jsutils/src/object/isObj.js","../../node_modules/@keg-hub/jsutils/src/method/isFunc.js","../../node_modules/@keg-hub/jsutils/src/string/isStr.js","../../node_modules/@keg-hub/jsutils/src/number/equalsNaN.js","../../node_modules/@keg-hub/jsutils/src/number/isNum.js","../../node_modules/@keg-hub/jsutils/src/ext/typeOf.js","../../node_modules/@keg-hub/jsutils/src/ext/isEmpty.js","../../node_modules/@keg-hub/jsutils/src/ext/isSame.js","../../node_modules/@keg-hub/jsutils/src/ext/isValidDate.js","../../node_modules/@keg-hub/jsutils/src/boolean/isBool.js","../../node_modules/@keg-hub/jsutils/src/string/toStr.js","../../node_modules/@keg-hub/jsutils/src/boolean/isStrBool.js","../../node_modules/@keg-hub/jsutils/src/boolean/convertToStrBool.js","../../node_modules/@keg-hub/jsutils/src/boolean/toBool.js","../../node_modules/@keg-hub/jsutils/src/collection/isColl.js","../../node_modules/@keg-hub/jsutils/src/collection/isEmptyColl.js","../../node_modules/@keg-hub/jsutils/src/collection/deepEqual.js","../../node_modules/@keg-hub/jsutils/src/ext/exists.js","../../node_modules/@keg-hub/jsutils/src/number/isNegative.js","../../node_modules/@keg-hub/jsutils/src/number/isPositive.js","../../node_modules/@keg-hub/jsutils/src/number/isFloat.js","../../node_modules/@keg-hub/jsutils/src/number/isInt.js","../../node_modules/@keg-hub/jsutils/src/object/hasOwn.js","../../node_modules/@keg-hub/jsutils/src/object/isEntry.js","../../node_modules/@keg-hub/jsutils/src/object/isArrMap.js","../../node_modules/@keg-hub/jsutils/src/object/jsonEqual.js","../../node_modules/@keg-hub/jsutils/src/string/isLowerCase.js","../../node_modules/@keg-hub/jsutils/src/string/isUpperCase.js","../../node_modules/@keg-hub/jsutils/src/string/isEmail.js","../../node_modules/@keg-hub/jsutils/src/string/isIp.js","../../node_modules/@keg-hub/jsutils/src/string/isPhone.js","../../node_modules/@keg-hub/jsutils/src/string/isUrl.js","../../node_modules/@keg-hub/jsutils/src/string/isUuid.js","../../node_modules/@keg-hub/jsutils/src/string/isQuoted.js","../../node_modules/@keg-hub/jsutils/src/url/isValidUrl.js","../../node_modules/@keg-hub/jsutils/src/method/isOrderable.js","../../node_modules/@keg-hub/jsutils/src/method/identity.js","../../node_modules/@keg-hub/jsutils/src/method/match.js","../../node_modules/@keg-hub/jsutils/src/dom/hasDomAccess.js","../../node_modules/@keg-hub/jsutils/src/regex/isRegex.js","../../node_modules/@keg-hub/jsutils/src/method/not.js","../../node_modules/@keg-hub/jsutils/src/object/deepFreeze.js","../../node_modules/@keg-hub/jsutils/src/ext/noOps.js","../../node_modules/@keg-hub/jsutils/src/method/checkCall.js","../../node_modules/@keg-hub/jsutils/src/method/complement.js","../../node_modules/@keg-hub/jsutils/src/method/eitherFunc.js","../../node_modules/@keg-hub/jsutils/src/method/debounce.js","../../node_modules/@keg-hub/jsutils/src/method/doIt.js","../../node_modules/@keg-hub/jsutils/src/method/memorize.js","../../node_modules/@keg-hub/jsutils/src/method/runSeq.js","../../node_modules/@keg-hub/jsutils/src/method/timedRun.js","../../node_modules/@keg-hub/jsutils/src/method/throttle.js","../../node_modules/@keg-hub/jsutils/src/method/throttleLast.js","../../node_modules/@keg-hub/jsutils/src/method/limbo.js","../../node_modules/@keg-hub/jsutils/src/method/uuid.js","../../node_modules/@keg-hub/jsutils/src/method/noOp.js","../../node_modules/@keg-hub/jsutils/src/method/parseErrorMessage.js","../../node_modules/@keg-hub/jsutils/src/method/stackTracePaths.js","../../node_modules/@keg-hub/jsutils/src/object/cloneJson.js","../../node_modules/@keg-hub/jsutils/src/object/clearObj.js","../../node_modules/@keg-hub/jsutils/src/object/eitherObj.js","../../node_modules/@keg-hub/jsutils/src/object/deepMerge.js","../../node_modules/@keg-hub/jsutils/src/object/applyToCloneOf.js","../../node_modules/@keg-hub/jsutils/src/object/mapEntries.js","../../node_modules/@keg-hub/jsutils/src/object/mapKeys.js","../../node_modules/@keg-hub/jsutils/src/object/mapObj.js","../../node_modules/@keg-hub/jsutils/src/object/omitKeys.js","../../node_modules/@keg-hub/jsutils/src/object/pickKeys.js","../../node_modules/@keg-hub/jsutils/src/object/sanitizeCopy.js","../../node_modules/@keg-hub/jsutils/src/object/trimStringFields.js","../../node_modules/@keg-hub/jsutils/src/object/toObj.js","../../node_modules/@keg-hub/jsutils/src/object/keyMap.js","../../node_modules/@keg-hub/jsutils/src/object/everyEntry.js","../../node_modules/@keg-hub/jsutils/src/object/someEntry.js","../../node_modules/@keg-hub/jsutils/src/object/filterObj.js","../../node_modules/@keg-hub/jsutils/src/object/hashObj.js","../../node_modules/@keg-hub/jsutils/src/object/splitByKeys.js","../../node_modules/@keg-hub/jsutils/src/object/transformKeys.js","../../node_modules/@keg-hub/jsutils/src/promise/promisify.js","../../node_modules/@keg-hub/jsutils/src/promise/promisifyAll.js","../../node_modules/@keg-hub/jsutils/src/promise/wait.js","../../src/types/helpers.types.ts","../../src/constants.ts","../../src/utils/errors.ts","../../src/test/utils.ts","../../src/test/runResult.ts","../../src/test/hooks.ts","../../src/utils/promiseRetry.ts","../../src/utils/promiseTimeout.ts","../../src/test/runTest.ts","../../src/test/runHelpers.ts","../../src/test/loopTests.ts","../../src/test/loopDescribes.ts","../../src/test/run.ts","../../src/test/test.ts"],"sourcesContent":["export * from './test'\n","/** @module Validation */\n\n/**\n * @type {Object}\n */\nconst OPTIONS = {\n  SHOULD_LOG: true,\n  SHOULD_THROW: false,\n  LOG_PREFIX: null,\n}\n\n// if no default or custom validator set for an arg, just assert it is valid\nconst defaultValidator = () => true\n\n/**\n *  Validates each key-value entry in argObj using the validator functions in validators with matching keys.\n *  <br/>For any failures, validate will console.error the reason.\n *  @param {Object} argObj - object, where keys are the name of the argument to validate, and value is its value\n *  @param {Object} validators - object, where keys match the argument and values are predicate functions (return true/false and are passed the arg with the same key).\n *     - Use the `$default` key to define a default validator, which will validate any argument that doesn't have a custom validator defined.\n *  @param {Object} options - contains `logs`, `throws`, and `prefix` props. When a validation fails, it will throw an error if `throws` is true. Else it logs error if `logs` is true. `prefix` prepends a string to the error messages.\n *  @returns {Array} - An entry with two values [ success, results ].<br/>\n *     - success: { Boolean } that is true if all arguments passed their validators, false otherwise<br/>\n *     - results: {Object} that holds the validation results for each argument, keyed by the same keys as in argObj. For each\n *                result object, the properties are: { success, key, value, validator, reason }.\n *  @function\n *  @example\n *    const elements = {}\n *    const name = 'michael'\n *    const address = '12345 E. Street'\n *    const [ isValid, results ] = validate(\n *      { elements, name, address },\n *      { elements: isArr, $default: isStr }\n *    )\n *    console.log(isValid) // false\n *    console.log(results.elements.success) // false\n */\nexport const validate = (argObj, validators = {}, options = {}) => {\n  const {\n    logs = OPTIONS.SHOULD_LOG,\n    throws = OPTIONS.SHOULD_THROW,\n    prefix = OPTIONS.LOG_PREFIX,\n  } = options\n\n  const validationCaseEntries = Object.entries(argObj)\n\n  // validate each argument\n  const validationResults = validationCaseEntries.map(([ argName, argValue ]) =>\n    validateArgument(\n      argName,\n      argValue,\n      validators[argName] || validators.$default || defaultValidator\n    )\n  )\n\n  // reduce the argument validation results into a single object of form { success, cases }.\n  // success is true if all arguments passed their validators. Cases holds each argument's validation results.\n  const reduceCases = (total, next) =>\n    validationReducer(total, next, { logs, throws, prefix })\n  const { success, cases } = validationResults.reduce(reduceCases, {\n    success: true,\n    cases: {},\n  })\n\n  return [ success, cases ]\n}\n\n/**\n * If you need to configure validation properties globally, you can do so here. These are overridden by the validate options arguments,\n * if one is defined in validate().\n * @function\n * @param {Object} options\n * @param {Boolean} options.logs - indicates you want validate() to log errors when a case fails\n * @param {Boolean} options.throws - indicates validate() should throw an error when a case fails\n * @param {String} options.prefix - a prefix to any console error logs or to messages of errors thrown\n */\nvalidate.setOptions = ({ logs, throws, prefix }) => {\n  if (logs !== undefined) {\n    OPTIONS.SHOULD_LOG = logs\n  }\n  if (throws !== undefined) {\n    OPTIONS.SHOULD_THROW = throws\n  }\n  if (prefix !== undefined) {\n    OPTIONS.LOG_PREFIX = prefix\n  }\n}\n\n/**\n * Resets the global validation options to their defaults\n * @function\n */\nvalidate.resetOptions = () => {\n  OPTIONS.SHOULD_LOG = true\n  OPTIONS.SHOULD_THROW = false\n  OPTIONS.LOG_PREFIX = null\n}\n\n/**\n * Helper for `validate`. Validates a single value given a validator\n * @param {*} key\n * @param {*} value\n * @param {Function} validator\n * @returns {Object} of form { success, reason }\n * @ignore\n */\nconst validateArgument = (key, value, validator) => {\n  const success = validator(value)\n\n  // if validator is a named function, use its name. If it is an inline anonymous arrow function, its name\n  // matches the argument key and it has no useful/descriptive name, so just stringify it\n  const shouldStringifyValidator =\n    !validator.name || validator.name === key || validator.name === '$default'\n  const validatorString = shouldStringifyValidator\n    ? validator.toString()\n    : validator.name\n\n  const reason = success\n    ? null\n    : [\n        `Argument \"${key}\" with value `,\n        value,\n        ` failed validator: ${validatorString}.`,\n      ]\n\n  return { success, key, value, validator, reason }\n}\n\n/**\n * Helper for `validate`. Reduces validations into a single object of form { success, cases }\n * @param {*} finalResult\n * @param {*} nextValidation\n * @ignore\n */\nconst validationReducer = (\n  finalResult,\n  nextValidation,\n  { logs, throws, prefix }\n) => {\n  // handle the failure\n  !nextValidation.success && handleFailure(nextValidation, logs, throws, prefix)\n\n  return {\n    success: finalResult.success && nextValidation.success,\n    cases: {\n      ...finalResult.cases,\n      [nextValidation.key]: nextValidation,\n    },\n  }\n}\n\n/**\n * Handles a validation failure given validation options\n * @param {Object} validation\n * @param {Boolean} shouldLog\n * @param {Boolean} shouldThrow\n * @param {String} prefix - optional prefix to any error or console log\n * @ignore\n */\nconst handleFailure = (validation, shouldLog, shouldThrow, prefix) => {\n  // prepend the prefix if one is defined\n  const reason = prefix ? [ prefix, ...validation.reason ] : validation.reason\n\n  if (shouldThrow) throw new Error(reason.join())\n\n  if (shouldLog) console.error(...reason)\n}\n","/** @module Array */\n\n/**\n * Checks if passed in value is an array.\n * @function\n * @example\n * isArr([1,2,3])\n * // Returns true\n * @param {any} value - value to be check if is an array\n * @return {Boolean} - T/F value is an array\n */\nexport const isArr = value => Array.isArray(value)\n","/** @module Object */\n\n/**\n * Checks if data is an object and not an array.\n * @function\n * @param {Object} obj - data to check\n * @returns {Boolean}\n */\nexport const isObj = obj =>\n  typeof obj === 'object' && !Array.isArray(obj) && obj !== null\n","/** @module Function */\n\n/**\n * Check if the passed in item is a function.\n * @example\n * isFunc(() => {})\n * // Returns true\n * @example\n * isFunc('bar')\n * // Returns false\n * @function\n * @param {*} test\n * @return {Boolean} is a function\n */\nexport const isFunc = func => typeof func === 'function'\n","/** @module String */\n\n/**\n * Check if passed in value is a string.\n * @function\n * @param {*} str - param to check if type is a string\n * @return {Boolean} - True if it's a string\n */\nexport const isStr = str => typeof str === 'string'\n","/** @module Number */\n\n/**\n * Checks if a value is NaN.\n * @example\n * equalsNaN(NaN)\n * // Returns true\n * @example\n * equalsNaN(1)\n * // Returns false\n * @example\n * equalsNaN('')\n * // Returns false\n * @function\n * @param {Number} val - value to check if is NaN\n * @return {Boolean} T/F - if value is a number\n */\nexport const equalsNaN = val => typeof val === 'number' && val != val\n","/** @module Number */\n\nimport { equalsNaN } from './equalsNaN'\n\n/**\n * Checks is value is a number.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt(NaN)\n * // Returns false\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {*} val - value to check if is a number\n * @return {Boolean} T/F - if value is a number\n */\nexport const isNum = val => typeof val === 'number' && !equalsNaN(val)\n","/** @module Extra */\n\n/**\n * Gets the type of the passed in val.\n * @example\n * typeOf(1)\n * // Returns Number\n * @example\n * typeOf('')\n * // Returns String\n * @function\n * @param {*} val - value to get type for\n * @return {String} type of the value\n */\nexport const typeOf = val => Object.prototype.toString.call(val).slice(8, -1)\n","/** @module Extra */\n\nimport { isObj } from '../object/isObj'\nimport { isArr } from '../array/isArr'\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\n\n/**\n * Checks if the value is empty.\n * @example\n * isEmpty('')\n * // Returns true\n * @example\n * isEmpty({})\n * // Returns true\n * @example\n * isEmpty([ 1 ])\n * // Returns false\n * @function\n * @param {*} val - value to check\n * @return {Boolean} if the value is empty\n */\nexport const isEmpty = val =>\n  isObj(val)\n    ? Object.keys(val).length === 0\n    : isArr(val)\n      ? val.length === 0\n      : isStr(val)\n        ? val.trim().length === 0\n        : isNum(val)\n          ? val < 1\n          : false\n","/** @module Extra */\n\n/**\n * Checks if the passed in values are exactly the same.\n * @example\n * isSame(1, 1)\n * // Returns true\n * @function\n * @param {*} val1 - value to compare\n * @param {*} val2 - value to compare\n * @return {Boolean} is the values are the same\n */\nexport const isSame = (val1, val2) =>\n  val1 === val2\n    ? val1 !== 0 || 1 / val1 === 1 / val2\n    : val1 !== val1 && val2 !== val2\n","/** @module Extra */\n\n/**\n * Checks is passed in date is a valid date.\n * @example\n * isValidDate(new Date())\n * // Returns true\n * @example\n * isValidDate(new Date().toString())\n * // Returns true\n * @example\n * isValidDate('12345678')\n * // Returns false\n * @function\n * @param { Date|String } date - value to check\n * @return {Boolean} T/F - if passed in date is a valid date\n */\nexport const isValidDate = date =>\n  !isNaN(((date instanceof Date && date) || new Date(date)).getTime())\n","/** @module Boolean */\n\n/**\n * Checks is value is a boolean.\n * @function\n * @example\n * isBool([1,2,3])\n * // Returns false\n * @example\n * isBool(true)\n * // Returns true\n * @param {*} val - value to check if is a number\n * @return {Boolean} True if val is a boolean\n */\nexport const isBool = val => typeof val === 'boolean'\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts a passed in value to a string.\n * @function\n * @param {*} val - value to be converted\n * @return {String} - value converted into a string\n */\nexport const toStr = val =>\n  val === null || val === undefined\n    ? ''\n    : isStr(val)\n      ? val\n      : JSON.stringify(val)\n","/** @module Boolean */\n\n/**\n * Checks is value is a boolean as a string.\n * @function\n * @example\n * isStrBool(\"true\")\n * // Returns true\n * @example\n * isStrBool(true)\n * // Returns false\n * @param {*} val - value to check if boolean as a string\n * @return {Boolean} True if val is a string boolean\n */\nexport const isStrBool = val => val === 'false' || val === 'true'\n","/** @module Boolean */\n\nimport { toStr } from '../string/toStr'\nimport { isBool } from './isBool'\n\n/**\n * Converts a value to a boolean as a string.\n * @function\n * @example\n * convertToStrBool(true)\n * // Returns 'true'\n * @param {*} val - value to convert to string boolean\n * @return {String} 'true' || 'false' based on passed in value\n */\nexport const convertToStrBool = val =>\n  isBool(val)\n    ? toStr(val)\n    : !val || val === 'false' || val === '0'\n        ? 'false'\n        : 'true'\n","/** @module Boolean */\n\nimport { isStrBool } from './isStrBool'\nimport { convertToStrBool } from './convertToStrBool'\n\n/**\n * Converts a value to a boolean.\n * @function\n * @example\n * toBool(null)\n * // Returns false\n * @example\n * toBool('false')\n * // Returns false\n * @example\n * toBool('true')\n * // Returns true\n * @param {*} val - value to convert\n * @return {Boolean} true or false based on passed in value.\n */\nexport const toBool = val =>\n  isStrBool(val) ? val === 'true' : convertToStrBool(val) === 'true'\n","/** @module Collection */\n\n/**\n * Checks if the value is a collection ( object || array ).\n * @example\n * isColl([1,2,3])\n * // Returns true\n * @example\n * isColl({ foo: 'bar' })\n * // Returns true\n * @example\n * isColl(null)\n * // Returns false\n * @function\n * @param {*} val - Value to check\n * @return {Boolean} True if the value is a collection (Object || Array)\n */\nexport const isColl = val => typeof val === 'object' && val !== null\n","/** @module Collection */\n\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Checks if passed in obj || array is empty.\n * @example\n * isEmptyColl({})\n * // Returns true\n * @example\n * isEmptyColl({ foo: 'bar' })\n * // Returns false\n * @example\n * isEmptyColl([])\n * // Returns true\n * @function\n * @param {*} obj - Object to check if empty\n * @return {Boolean} - True if the passed in collection is empty\n */\nexport const isEmptyColl = obj =>\n  isArr(obj)\n    ? obj.length === 0\n    : isColl(obj) && Object.getOwnPropertyNames(obj).length === 0\n","/** @module Collection */\n\n// Cache the prototype methods for faster access\nconst isArray = Array.isArray\nconst keyList = Object.keys\nconst hasProp = Object.prototype.hasOwnProperty\n\n/**\n * Recursively checks if two collections are equal\n * <br/>Faster the JSON.stringify checks\n * <br/>See https://jsperf.com/fast-deep-equal-vs-json-stringify\n * @example\n * const test = { foo: [ { bar: 'baz' } ] }\n * const test2 = { foo: [ { bar: 'baz' } ] }\n * console.log(test === test2)) // prints false\n * deepEqual(test, test2) // returns true\n * @example\n * // Works with arrays too\n * deepClone([ [ [ 0 ] ] ], [ [ [ 0 ] ] ]) // returns true\n * @function\n * @param {Object|Array} a - Object to check\n * @param {Object|Array} b - Object to check against\n */\nexport const deepEqual = (a, b) => {\n  if (a === b) return true\n\n  if (!a || !b || typeof a != 'object' || typeof b != 'object')\n    return a !== a && b !== b\n\n  const arrA = isArray(a)\n  const arrB = isArray(b)\n  let i\n  let length\n  let key\n\n  // If both are arrays\n  if (arrA && arrB) {\n    length = a.length\n    // If unequal length, then not equal\n    if (length != b.length) return false\n    // Loop the arrays and check the contents of both\n    for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false\n\n    return true\n  }\n\n  // If on is an array and the other is not, then return false\n  if (arrA != arrB) return false\n\n  // Validate date objects\n  const dateA = a instanceof Date\n  const dateB = b instanceof Date\n  if (dateA != dateB) return false\n  if (dateA && dateB) return a.getTime() == b.getTime()\n\n  // Validate RegExp objects\n  const regexpA = a instanceof RegExp\n  const regexpB = b instanceof RegExp\n  if (regexpA != regexpB) return false\n  if (regexpA && regexpB) return a.toString() == b.toString()\n\n  // Cache the keys and length for faster iteration\n  const keys = keyList(a)\n  length = keys.length\n\n  // If unequal key length then return false\n  if (length !== keyList(b).length) return false\n\n  // Ensure both objects have the same keys\n  for (i = length; i-- !== 0;) if (!hasProp.call(b, keys[i])) return false\n\n  // Check the value of the object keys\n  for (i = length; i-- !== 0;) {\n    key = keys[i]\n    if (!deepEqual(a[key], b[key])) return false\n  }\n\n  return true\n}\n","/** @module Extra */\n\n/**\n * Checks if a value exists. NOT undefined || null\n * @function\n * @example\n * exists(0)\n * // Returns true\n * @example\n * exists(null)\n * // Returns false\n * exists('')\n * // Returns true\n * exists(NaN)\n * // Returns false\n * @param {*} value - Item to check if exists\n *\n * @returns {Boolean} - If the item exists or not\n */\nexport const exists = value =>\n  value === value && value !== undefined && value !== null\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * @function\n * @param {*} x\n * @returns { boolean } true if x is a negative number\n * @example isNegative(-1) // true\n * @example isNegative(0) // false\n */\nexport const isNegative = x => isNum(x) && x < 0\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * @function\n * @param {*} x\n * @returns { boolean } true if x is a positive number\n * @example isPositive(0) // false\n * @example isPositive(1) // true\n */\nexport const isPositive = x => isNum(x) && x > 0\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if a number is a Float.\n * @example\n * isFloat(1.23)\n * // Returns true\n * @example\n * isFloat('1.2')\n * // Returns false ( because it's a string )\n * @function\n * @param {Number} num - value to check\n * @return {Boolean} true or false - value is an Float\n */\nexport const isFloat = val => isNum(val) && val % 1 !== 0\n","/** @module Number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if a number is an integer.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {Number} num - value to check\n * @return {Boolean} true or false - value is an Int\n */\nexport const isInt = val => isNum(val) && val % 1 === 0\n","/** @module Object */\n\n/**\n * Checks if prop exists on the object.\n * @function\n * @param {Object} obj - data to check\n * @param {String} prop - prop to check for\n * @returns {Boolean} T/F if the prop exists\n */\nexport const hasOwn = (obj, prop) =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","/** @module Object */\n\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\nimport { isArr } from '../array/isArr'\n\n/**\n * Checks if the input is a valid entry - a 2-element array, like what Object.entries produces.\n * Expects the first element in the entry to be either a string or a number.\n * @function\n * @example isEntry([1, 2]) // true\n * @example isEntry([\"id\", 87]) // true\n * @example isEntry([new Date(), 2]) // false, first element not string or number\n * @example isEntry([1, 2, 3]) // false, too many elements\n * @param {*} maybeEntry - Item to check if it's an entry\n *\n * @returns {Boolean} - True if it is an entry, false otherwise\n */\nexport const isEntry = maybeEntry =>\n  isArr(maybeEntry) &&\n  maybeEntry.length === 2 &&\n  (isNum(maybeEntry[0]) || isStr(maybeEntry[0]))\n","/** @module Object */\n\nimport { isObj } from './isObj'\nimport { isArr } from '../array/isArr'\nimport { toBool } from '../boolean/toBool'\n\n/**\n * Returns true if the input is an object and every value is an array\n * @function\n * @param {Object|*} obj - data to check\n * @return {Boolean} - true if input is an array map\n */\nexport const isArrMap = obj => {\n  if (!isObj(obj)) return false\n  const values = Object.values(obj)\n  return toBool(values.length && values.every(isArr))\n}\n","/** @module Object */\n\n/**\n * Compares two objects by converting to JSON, and checking string equality.\n * @function\n * @param { object | array } one - object to compare with param two\n * @param { object | array } two - object to compare with param one\n * @return {Boolean} status of equality\n */\nexport const jsonEqual = (one, two) => {\n  try {\n    return JSON.stringify(one) === JSON.stringify(two)\n  }\n  catch (e) {\n    return false\n  }\n}\n","/** @module String */\n\n/**\n * Checks if a string is all lowercase letters\n * @function\n * @param {String} str - String to check if it's lowercase\n * @returns {Boolean} - True if str is lowercase\n */\nexport const isLowerCase = str => str === str.toLowerCase()\n","/** @module String */\n\n/**\n * Checks if a string is all capital letters\n * @function\n * @param {String} str - String to check if it's uppercase\n * @returns {Boolean} - True if str is uppercase\n */\nexport const isUpperCase = str => str === str.toUpperCase()\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a email.\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's a email\n */\nexport const isEmail = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\nconst regex = {\n  ipv4: /^(?:(?:\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(?:\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$/,\n  ipv6: /^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i,\n}\n\n/**\n * Check if string is an Ip address, both Ip4 and Ip6\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's an Ip address\n */\nexport const isIp = str => {\n  if (!str || !isStr(str)) return false\n\n  const isIp4 = Boolean(regex.ipv4.test(str))\n  return isIp4 || Boolean(regex.ipv6.test(str))\n}\n\n/**\n * Check if string is an IP4 address\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's an IP4 address\n */\nexport const isIp4 = str => {\n  if (!str || !isStr(str)) return false\n\n  return Boolean(regex.ipv4.test(str))\n}\n\n/**\n * Check if string is an IP6 address\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's an IP6 address\n */\nexport const isIp6 = str => {\n  if (!str || !isStr(str)) return false\n\n  return Boolean(regex.ipv6.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a phone number.\n * @function\n * @param {String} str - string to check\n * @return {Boolean} - True if str is a phone number\n */\nexport const isPhone = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/im\n  return Boolean(regex.test(str)) && str.replace(/\\D/g, '').length < 11\n}\n","/** @module String */\n\n/**\n * Check if string is a url.\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's a url\n */\nexport const isUrl = str => {\n  const regex =\n    /^(?:(?:https?|ftp):\\/\\/)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a uuid.\n * @function\n * @param {String} str - string to check\n * @return {Boolean} - if it's a uuid\n */\nexport const isUuid = str => {\n  if (!str || !isStr(str)) return false\n  const regex =\n    /^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\nconst quoteSymbols = [ '\"', \"'\" ]\n\n/**\n * Checks if the string contains quoted text\n * @function\n * @param {String} str - string to check\n * @param {Array<string>?} [quotes] - optional array of valid quote strings to check with. Defaults to single and double quote characters.\n * @return {Boolean} true if `str` is a quoted string\n * @example\n * isQuoted('foo') // false\n * @example\n * isQuoted('\"foo\"') // true\n */\nexport const isQuoted = (str, quotes = quoteSymbols) => {\n  return (\n    isStr(str) &&\n    quotes.some(quote => str.startsWith(quote) && str.endsWith(quote))\n  )\n}\n","/** @module Url */\n\n/**\n * Checks if the given string is a valid URL\n * Must begin with ftp/http/https\n * @param {String} str - any string to check if it's a valid url\n * @function\n * @returns {Boolean}\n */\nexport const isValidUrl = str => {\n  var regexp =\n    /(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-/]))?/\n\n  return regexp.test(str)\n}\n","/** @module Function */\n\nimport { isStr } from '../string'\nimport { isBool } from '../boolean'\nimport { isNum } from '../number'\n\n/**\n * Checks if param is an orderable primitive\n * @function\n * @param {*} x\n * @returns {bool} - true if x is a comparable primitive\n */\nexport const isOrderable = x => isStr(x) || isNum(x) || isBool(x)\n","/** @module Function */\n\n/**\n * A function that simply returns its input\n * @function\n * @param {*} x\n * @returns {*} the input\n */\nexport const identity = x => x\n","/** @module Function */\n\nimport { isArr } from '../array/isArr'\nimport { typeOf } from '../ext/typeOf'\nimport { isFunc } from './isFunc'\n\n/**\n * Pattern matching function. Iterates through the entries,\n * <br/>which have the form [ check value or predicate, return value ], and\n * <br/>when it encounters an entry whose check value matches the matchArg\n * <br/>(or the predicate returns true when passed the matchArg), it returns\n * <br/>the return value of that entry.\n *\n * For the default case: use [ match.default, <your default value> ]\n * @function\n *\n * @param {*} matchArg - the argument to match against the cases\n * @param {Array} entries - the cases to match against the matchArg\n * @returns {*} - the return value of the first entry with a matching check value, else null\n *\n * @example\n * const value = 1\n * match(value,\n *  [ 1, \"hello\" ],\n *  [ x => x > 2, \"greater\" ]\n *  [ match.default, \"defaulted\"]\n * )\n * => returns \"hello\"\n *\n * @example\n * const value = 3\n * match(value,\n *  [ 1, \"hello\" ],\n *  [ x => x > 2, \"greater\" ]\n * )\n * => returns \"greater\"\n *\n * @example\n * // react reducer:\n *function todoReducer(state, action) {\n *   const reducer = match(action.type,\n *       [ 'ADD-TODO', addTodo ],\n *       [ 'REMOVE-TODO', removeTodo ],\n *       [ 'UPDATE-TODO', updateTodo ],\n *       [ match.default, state ]\n *   )\n *\n *   return reducer(state, action)\n *}\n */\nexport const match = (matchArg, ...args) => {\n  if (!args.length) return null\n\n  // check all cases and return a value if a match is found\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(\n        `Matching case must be an entry (a 2-element array). Found: ${typeOf(\n          entry\n        )}`,\n        entry\n      )\n      break\n    }\n    const [ caseValueOrPredicate, valueOnMatch ] = entry\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg))\n      return valueOnMatch\n    if (caseValueOrPredicate === matchArg) return valueOnMatch\n  }\n\n  return null\n}\n\n/**\n * The default case function you can use with match. Just returns true so the case value can be used.\n * @function\n * @example\n * match(foo\n *    [ 100, 'a' ],\n *    [ 200, 'b' ],\n *    [ match.default, 'default value' ]\n * )\n */\nmatch.default = () => true\n","/** @module Dom */\n\n/**\n * Checks if there is access to the dom\n * @function\n * @example\n * // In Browser\n * hasDomAccess() === true\n * // In Node\n * hasDomAccess() === false\n * @return {Boolean} True if executed in a browser\n */\nexport const hasDomAccess = () => {\n  try {\n    return !!(\n      typeof window !== 'undefined' &&\n      window.document &&\n      window.document.createElement\n    )\n  }\n  catch (error) {\n    return false\n  }\n}\n\nexport { hasDomAccess as isDom }\n","/** @module RegEx */\n\n/**\n * Checks if value is an instance of regex\n * @function\n * @param {*} val\n * @return {Boolean} true if val is an instance of RegExp\n * @example\n * isRegex(new RegExp('a')) // true\n * isRegex(/a/) // true\n * isRegex('a') // false\n */\nexport const isRegex = val => Boolean(val && val instanceof RegExp)\n","/** @module Function */\n\nimport { isBool } from '../boolean/isBool'\nimport { isStrBool } from '../boolean/isStrBool'\n\nimport { isColl } from '../collection/isColl'\nimport { isEmptyColl } from '../collection/isEmptyColl'\nimport { deepEqual } from '../collection/deepEqual'\n\nimport { isDom } from '../dom/hasDomAccess'\n\nimport { exists } from '../ext/exists'\nimport { isEmpty } from '../ext/isEmpty'\nimport { isSame } from '../ext/isSame'\nimport { isValidDate } from '../ext/isValidDate'\n\nimport { isFunc } from './isFunc'\nimport { identity } from './identity'\nimport { isOrderable } from './isOrderable'\n\nimport { equalsNaN } from '../number/equalsNaN'\nimport { isFloat } from '../number/isFloat'\nimport { isInt } from '../number/isInt'\nimport { isNum } from '../number/isNum'\nimport { isNegative } from '../number/isNegative'\nimport { isPositive } from '../number/isPositive'\n\nimport { hasOwn } from '../object/hasOwn'\nimport { isEntry } from '../object/isEntry'\nimport { isArrMap } from '../object/isArrMap'\nimport { isObj } from '../object/isObj'\nimport { jsonEqual } from '../object/jsonEqual'\n\nimport { isRegex } from '../regex/isRegex'\n\nimport { isEmail } from '../string/isEmail'\nimport { isIp } from '../string/isIp'\nimport { isLowerCase } from '../string/isLowerCase'\nimport { isPhone } from '../string/isPhone'\nimport { isQuoted } from '../string/isQuoted'\nimport { isStr } from '../string/isStr'\nimport { isUpperCase } from '../string/isUpperCase'\nimport { isUrl } from '../string/isUrl'\nimport { isUuid } from '../string/isUuid'\n\nimport { isValidUrl } from '../url/isValidUrl'\n\n/**\n * When called, it calls original function, then returns inverse of the functions result\n * <br/>Should be used with functions that return a boolean\n * @function\n * @param {Function} func - Function call and invert its response\n *\n * @returns {Function} - Calls the passed in function then returns True if the passed in function returns falsy, otherwise false\n */\nexport const not = func => {\n  return (...args) => !func.apply(null, args)\n}\n\nnot.bool = not(isBool)\nnot.strBool = not(isStrBool)\nnot.coll = not(isColl)\nnot.deepEqual = not(deepEqual)\nnot.emptyColl = not(isEmptyColl)\nnot.dom = not(isDom)\nnot.exists = not(exists)\nnot.empty = not(isEmpty)\nnot.same = not(isSame)\nnot.validDate = not(isValidDate)\nnot.func = not(isFunc)\nnot.identity = not(identity)\nnot.orderable = not(isOrderable)\nnot.equalsNaN = not(equalsNaN)\nnot.float = not(isFloat)\nnot.int = not(isInt)\nnot.num = not(isNum)\nnot.negative = not(isNegative)\nnot.positive = not(isPositive)\nnot.hasOwn = not(hasOwn)\nnot.entry = not(isEntry)\nnot.arrMap = not(isArrMap)\nnot.obj = not(isObj)\nnot.jsonEqual = not(jsonEqual)\nnot.regex = not(isRegex)\nnot.email = not(isEmail)\nnot.ip = not(isIp)\nnot.lowerCase = not(isLowerCase)\nnot.phone = not(isPhone)\nnot.quoted = not(isQuoted)\nnot.str = not(isStr)\nnot.upperCase = not(isUpperCase)\nnot.url = not(isUrl)\nnot.uuid = not(isUuid)\nnot.validUrl = not(isValidUrl)\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Recursively freezes and object.\n * @function\n * @param {Object} obj\n * @return {Object} - frozen Object\n */\nexport const deepFreeze = obj => {\n  Object.freeze(obj)\n  Object.getOwnPropertyNames(obj).map(prop => {\n    obj.hasOwnProperty(prop) &&\n      obj[prop] !== null &&\n      (typeof obj[prop] === 'object' || isFunc(obj[prop])) &&\n      !Object.isFrozen(obj[prop]) &&\n      deepFreeze(obj[prop])\n  })\n\n  return obj\n}\n","/** @module Extra */\n\nimport { deepFreeze } from '../object/deepFreeze'\n\n/**\n * Reuseable empty, frozen object\n * @object\n * @type {Object}\n */\nexport const noOpObj = Object.freeze({})\n\n/**\n * Reuseable empty, frozen object\n * @object\n * @type {Object}\n */\nexport const emptyObj = noOpObj\n\n/**\n * Reusable frozen object that contains a `content` object. Useful\n * @object\n * for themes that rely on the content key.\n * @type {Object}\n */\nexport const noPropObj = deepFreeze({ content: {} })\n\n/**\n * Reusable, empty frozen array\n * @array\n * @type {Array}\n */\nexport const noPropArr = deepFreeze([])\n\n/**\n * Reusable, empty frozen array.\n * Renamed for consistency\n * @array\n * @type {Array}\n */\nexport const noOpArr = noPropArr\n\n/**\n * Reusable, empty frozen array.\n * Renamed for legibility\n * @array\n * @type {Array}\n */\nexport const emptyArr = noPropArr\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Check if the passed in method is a function, and calls it\n * @example\n * checkCall((param1) => { return param1 }, 'foo')\n * // Returns 'foo'\n * @function\n * @param {Function} method - function to call\n * @param {Object} params - params to pass to the method on call\n * @return {*} - whatever the passed in method returns\n */\nexport const checkCall = (method, ...params) => {\n  return isFunc(method) ? method(...params) : undefined\n}\n\nexport {\n  checkCall as ife,\n  checkCall as iife,\n}","/** @module Function */\n\nimport { validate } from '../validation'\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Returns a new function that is the complement of predicate function `predicate`\n * @function\n * @param {Function} predicate\n * @returns {Function?} the complement of `predicate`, if it's a function, otherwise null\n * @example\n * const isNegative = x => (x < 0)\n * const isNonNegative = complement(isNegative)\n * isNonNegative(1) // true\n */\nexport const complement = predicate => {\n  const [valid] = validate({ predicate }, { predicate: isFunc })\n  return valid ? (...args) => !predicate(...args) : null\n}\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Returns the first param if it's a function.\n * <br/>If first param is not a function, returns second param.\n * @example\n * eitherFunc(() => {}, 'bar')\n * // Returns first param because it's a function.\n * @example\n * eitherFunc('foo', 'bar')\n * // Returns 'bar'\n * @function\n * @param {Function} func1 - return if is func\n * @param {Function} func2 - use if first is not an object\n * @returns {Function}\n */\nexport const eitherFunc = (func1, func2) => (isFunc(func1) && func1) || func2\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Limits the amount of calls to a function over time\n * @example\n * debounce(myFunction)\n * // Calls myFunction after the default 250 ms\n * @example\n * debounce(myFunction, 500)\n * // Calls myFunction after 500 ms\n * @example\n * debounce(myFunction, 500, true)\n * // Calls myFunction immediately\n * @function\n * @param {Function} func - function to call\n * @param {Number} wait - how long to wait between function calls\n * @param {Boolean} immediate - should call immediately\n * @return { void }\n */\nexport const debounce = (func, wait = 250, immediate = false) => {\n  let timeout\n  function wrapFunc(...args) {\n    if (!isFunc(func)) return null\n\n    const context = this\n    const later = () => {\n      timeout = null\n      !immediate && func.apply(context, args)\n    }\n    const callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow) return isFunc(func) && func.apply(context, args)\n  }\n  return wrapFunc\n}\n","/** @module Function */\n\nimport { isNum } from '../number/isNum'\nimport { isFunc } from './isFunc'\n\n/**\n * Execute a method n times.\n * <br/>Callback params - does not include number || callback method\n * @function\n * @example\n * doIt(10, window, [], (index, arr) => { arr.push(index) }) === [ 0,1,2 ... 8,9 ]\n * @param {Number} args.0 - number of times to call the callback\n * @param {parent} args.1 - value to bind the method call to ( this )\n * @param {Function} last arg of args array - method to call\n * @return { void }\n */\nexport const doIt = (...args) => {\n  const params = args.slice()\n  const num = params.shift()\n  const bindTo = params.shift()\n  const cb = params.pop()\n  if (!isNum(num) || !isFunc(cb)) return []\n\n  const doItAmount = new Array(num)\n  const responses = []\n  for (let i = 0; i < doItAmount.length; i++) {\n    const data = cb.call(bindTo, i, ...params)\n    if (data === false) break\n    responses.push(data)\n  }\n\n  return responses\n}\n","/** @module Function */\n\nimport { isNum } from '../number/isNum'\nimport { hasOwn } from '../object/hasOwn'\nimport { isFunc } from './isFunc'\n\n/**\n * Creates a method to memorize passed in methods output\n * @example\n * memorize(myFunction, cacheKeyFunction)\n * @example\n * memorize(myFunction, cacheKeyFunction, 100)\n * @function\n * @param {Function} func - method to memorize output of\n * @param {Function} getCacheKey - gets the key to save cached output\n *\n * @return {Function} memorized function with cache\n */\nexport const memorize = (func, getCacheKey, limit = 1) => {\n  if (!isFunc(func) || (getCacheKey && !isFunc(getCacheKey)))\n    return console.error('Error: Expected a function', func, getCacheKey)\n\n  let memorized = function () {\n    const cache = memorized.cache\n    const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0]\n\n    if (hasOwn(cache, key)) return cache[key]\n\n    const result = func.apply(this, arguments)\n\n    isNum(limit) && Object.keys(cache).length < limit\n      ? (cache[key] = result)\n      : (memorized.cache = { [key]: result })\n\n    return result\n  }\n\n  memorized.cache = {}\n  memorized.destroy = () => {\n    getCacheKey = undefined\n    memorized.cache = undefined\n    memorized.destroy = undefined\n    memorized = undefined\n  }\n\n  return memorized\n}\n","/** @module Function */\n\nimport { validate } from '../validation/validate'\nimport { isArr } from '../array/isArr'\nimport { isFunc } from './isFunc'\n\nimport { deepClone } from '../collection/deepClone'\n\n/**\n * Calls each promise-returning function in array `asyncFns`,\n * but awaits each before calling the next. Will pass the\n * index and resolved values of complete functions to each subsequent\n * function, in case any need them.\n * @function\n * @param {Array<Function>} asyncFns - array of functions to call in sequence.\n * Each will be passed (currentIndex, resultsSoFar)\n * @param {boolean?} [options.cloneResults=false] - if true, each function will be\n * passed a deep clone of the results array, rather than the reference to it.\n * @param {boolean?} [options.returnOriginal=true] - if true, any member of asyncFns that\n * is not a function will have its corresponding value in the return array be itself.\n * If this is false, that value will be undefined.\n * @return {Promise<Array<*>>} - returns a promise that resolves to an array of all the\n * asyncFns' return values\n * @example\n * const results = await runSeq(asyncFunctions)\n * @example\n * const results = await runSeq(asyncFunctions, { cloneResults: true, returnOriginal: false })\n */\nexport const runSeq = async (asyncFns = [], options = {}) => {\n  const [valid] = validate({ asyncFns }, { asyncFns: isArr })\n  if (!valid) return []\n\n  const { cloneResults = false, returnOriginal = true } = options\n\n  const results = []\n\n  for (const fn of asyncFns) {\n    const result = isFunc(fn)\n      ? await fn(results.length, cloneResults ? deepClone(results) : results)\n      : returnOriginal\n        ? fn\n        : undefined\n    results.push(result)\n  }\n\n  return results\n}\n","/** @module Function */\n\nimport { validate } from '../validation/validate'\nimport { isFunc } from './isFunc'\n\n/**\n * Executes and times the function `fn`.\n * @function\n * @param {Function} fn\n * @param {...*?} args - any number of arguments to pass to fn when it is called\n * @return {Promise<Array<*, number>>} [ fn output, execution time in ms ]\n * @example\n * const [ result, executionTime ] = timedRun(() => http.get(url)))\n * @example\n * const [ result, executionTime ] = timedRun(http.get, url)\n */\nexport const timedRun = async (fn, ...args) => {\n  const [valid] = validate({ fn }, { fn: isFunc })\n  if (!valid) return [ undefined, -1 ]\n\n  const startTime = new Date()\n  const result = await fn(...args)\n  return [ result, new Date() - startTime ]\n}\n","/** @module Function */\n\n/**\n * Throttle function calls to only execute once over a wait period\n * @example\n * throttle(() => console.log('throttled'), 50)()\n * @function\n * @param {*} func - method to call after wait\n * @param {Number} [wait=100] time to wait between calls\n * @return {Function} throttled function\n */\nexport const throttle = (func, wait = 100) => {\n  let waiting = false\n  return function (...args) {\n    if (waiting) return\n    waiting = true\n    func.apply(this, args)\n    return setTimeout(() => {\n      waiting = false\n    }, wait)\n  }\n}\n","/** @module Function */\n\nimport { isNum } from '../number'\n\n/**\n * Ensures the last call to the throttled function get called.\n * <br/>Will wait the allotted time, before calling the last call to it.\n * <br/>The final call will not execute until no more calls are made,\n * <br/>Accepts a callback to call each time the throttle called,\n * @example\n * throttleLast(() => {}, () => {})()\n * // throttle function\n * @function\n * @param {Function} func - method to call after wait\n * @param {Function} cb - method to call after throttle function is called\n * @param {Number} [wait=100] time to wait until executing func param\n * @return {Function} throttled function\n */\nexport const throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout\n\n  // Allow not passing in the cb, and just the func, and wait time\n  if(isNum(cb)){\n    wait = cb\n    cb = undefined\n  }\n  \n  return function (...args) {\n    // If the throttle already exists clear it, and create it again\n    if (throttleTimeout) clearTimeout(throttleTimeout)\n    // Store a reference to the timeout\n    // Will wait the allotted time until calling the final call to it\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args)\n      clearTimeout(throttleTimeout)\n    }, wait)\n  \n    typeof cb === 'function' && cb()\n  }\n}\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\nimport { emptyObj } from '../ext/noOps'\n\n/**\n * Response returned from a limbo promise\n * @typedef TLimboResponse\n * @private\n * @type {Array}\n */\n\n/**\n * Adds catch to a promise for better error handling of await functions\n * <br/>Removes the need for wrapping await in a try / catch\n * <br/>First argument is an Error when the promise throws or null when it resolves\n * <br/>Second argument is the response from the resolved promise\n * @example\n * const [ err, data ] = await limbo(promiseFunction())\n * // returns an array\n * // * err will be undefined if no error was thrown\n * // * data will be the response from the promiseFunction\n * @function\n * @param {Promise<Function>} promise - Promise to be resolved\n * @param {boolean} [asObject=false] - 2nd argument in resp array should be an object when an error is caught\n * @return {Promise<TLimboResponse>} - Slot 1 => error, Slot 2 => response from promise\n */\nexport const limbo = (promise, asObject=false) => {\n  return !promise || !isFunc(promise.then)\n    ? [\n        new Error(`A promise or thenable is required as the first argument!`),\n        asObject ? emptyObj : undefined,\n      ]\n    : promise.then(data => [ null, data ]).catch(err => [ err, asObject ? emptyObj : undefined ])\n}\n\n/**\n * Converts a method with a callback as the last argument into a promise\n * @function\n * @param {*} cb - method to wrap in a promise\n * @param {*} args - Arguments to pass to the callback method\n * @example\n * limboify(fs.rename, 'my/file.txt', 'my/renamed-file.txt')\n * @example\n * limboify(fs.mkdir, 'my/new/directory', { recursive: true })\n *\n * @returns {Promise|*} - Success response of fs.rename method\n */\nexport const limboify = (cb, ...args) => {\n  return limbo(\n    new Promise((res, rej) =>\n      cb(...args, (err, success) => (err ? rej(err) : res(success || true)))\n    )\n  )\n}\n","/** @module Function */\n\n/**\n * Creates a uuid, unique up to around 20 million iterations.\n * @example\n * uuid()\n * // New uuid as a string\n * @function\n * @param {Number} [start] of the uuid\n * @return {String} - build uuid\n */\nexport const uuid = a =>\n  a\n    ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)\n    : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid)\n","/** @module Function */\n\n/**\n * Reusable empty function that is a no-op\n * @function\n * @returns {void}\n */\nexport const noOp = () => {}\n","/** @module Function */\n\nimport { isStr } from '../string/isStr'\nimport { isObj } from '../object/isObj'\nimport { isEmpty } from '../ext/isEmpty'\n\n/**\n * Extracts the message from the exception, whether string or object\n * @function\n * @param {*} exception - Error to be extracted\n * @return {string?} - The message or null if no message is present\n * @example\n * try {\n *   throwSomeException()\n * }\n * catch (err) {\n *   const message = parseErrorMessage(err) || 'Error'\n * }\n */\nexport const parseErrorMessage = exception => {\n  return isStr(exception) && !isEmpty(exception)\n    ? exception\n    : isObj(exception)\n      ? exception.message\n      : null\n}\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\nconst defFilters = [ `node:internal`, `node_modules/jest` ]\n\n/**\n * Gets the paths from a stacktrace as CallSites and returns them\n * @function\n * @param {Array|Function} filter - List of paths to ignore, or function that returns truthy to ignore\n *\n * @returns {Array<string>} - List of paths from the stackTrace\n */\nexport const stackTracePaths = (filter = defFilters) => {\n  const orgPreStackTrace = Error.prepareStackTrace\n  Error.prepareStackTrace = (_, stack) => stack\n\n  const stack = new Error().stack.slice(1)\n  Error.prepareStackTrace = orgPreStackTrace\n\n  return stack.reduce((acc, cs) => {\n    const loc = cs.getFileName()\n    if (!loc) return acc\n\n    const ignore = isFunc(filter)\n      ? filter(loc, cs, stack)\n      : Boolean(\n        filter.length && filter.find(filterLoc => loc.includes(filterLoc))\n      )\n\n    !ignore && acc.push(loc)\n\n    return acc\n  }, [])\n}\n","/** @module Object */\n\nimport { logData } from '../log'\n\n/**\n * Clones an object by converting to JSON string and back.\n * @function\n * @param {Object} obj - object to clone\n * @returns {Object} copy of original object\n */\nexport const cloneJson = obj => {\n  try {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  catch (e) {\n    logData(e.message, 'error')\n    return null\n  }\n}\n","/** @module Object */\n\n/**\n * Removes all properties from an object.\n * @function\n * @param {Object} obj - object to remove properties from\n * @param {Array} [filter] - list of keys to not remove\n * @returns {void}\n */\nexport const clearObj = (obj, filter) => {\n  obj &&\n    Object.entries(obj).map(([ key, value ]) => {\n      if (filter && filter.indexOf(key) !== -1) return\n      if (typeof value === 'object') clearObj(value)\n      obj[key] = undefined\n      delete obj[key]\n    })\n}\n","/** @module Object */\n\nimport { isObj } from './isObj'\n\n/**\n * Returns the first param if correct type of second param.\n * @function\n * @param {Object} obj1 - return if is object\n * @param {Object} obj2 - use if first is not an object\n * @returns {Object}\n */\nexport const eitherObj = (obj1, obj2) => (isObj(obj1) && obj1) || obj2\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { cloneFunc } from '../method/cloneFunc'\nimport { isArr } from '../array/isArr'\nimport { isObj } from './isObj'\nimport { deepClone } from '../collection/deepClone'\nimport { isColl } from '../collection/isColl'\n\n/**\n * Deep merges an array of objects together.\n * @function\n * @param {Array} sources - array of objects to join\n * @returns {Object|Array} - merged object or array\n */\nexport const deepMerge = (...sources) => {\n  return sources.reduce((merged, source) => {\n    const srcCopy = deepClone(source)\n    return isArr(srcCopy)\n      ? // Check if it's array, and join the arrays\n        [ ...((isArr(merged) && merged) || []), ...srcCopy ]\n      : // Check if it's an object, and loop the properties\n      isObj(srcCopy)\n        ? // Loop the entries of the object, and add them to the merged object\n        Object.entries(srcCopy).reduce(\n          (joined, [ key, value ]) => ({\n            ...joined,\n            // Check it's a function, and if so, clone it\n            [key]: isFunc(value)\n              ? cloneFunc(value)\n              : // Check if the value is an object of if key is in the object\n              isColl(value) && key in joined\n                ? // Set to value or deepMerge the object with the current merged object\n                deepMerge(joined[key], value)\n                : // Otherwise just clone and set the value\n                deepClone(value),\n            // Pass in merged at the joined object\n          }),\n          merged\n        )\n        : // If it's not an array or object, just return the merge object\n        merged\n    // Check the first source to decide what to merged value should start as\n  }, (isArr(sources[0]) && []) || {})\n}\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { deepClone } from '../collection/deepClone'\nimport { isObj } from './isObj'\n\n/**\n * Deep clones Object obj, then returns the result of calling function mutatorCb with the clone as its argument\n * @example\n * const obj = {}\n * const clone = applyToCloneOf(obj, (clone) => { clone.test = 'foo'; return clone })\n * console.log(obj === clone) // prints false\n * console.log(clone.test === 'foo') // prints true\n * @function\n * @param {Object} obj - object\n * @param {Function} mutatorCb - a callback that accepts one argument, the cloned obj, and mutates it in some way\n * @returns {Object|Array} the mutated clone\n */\nexport const applyToCloneOf = (obj, mutatorCb) => {\n  let error\n  if (!obj) error = 'object (Argument 1) in applyToCloneOf, must be defined!'\n\n  if (!isObj(obj))\n    error = 'object (Argument 1) in applyToCloneOf, must be an object!'\n\n  if (!mutatorCb)\n    error = 'mutator (Argument 2) in applyToCloneOf, must be defined!'\n\n  if (!isFunc(mutatorCb))\n    error = 'mutator (Argument 2) arg in applyToCloneOf, must be a function!'\n\n  if (error) {\n    console.warn(error)\n\n    return obj\n  }\n\n  const clone = deepClone(obj)\n  mutatorCb(clone)\n\n  return clone\n}\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { set } from '../collection/set'\nimport { isArr } from '../array/isArr'\nimport { isObj } from './isObj'\nimport { isEntry } from './isEntry'\n\n/**\n * Returns a new object, each entry of which is the result of applying the cb function to input's corresponding entry\n * @param {Object|Array} obj - regular object or array\n * @param {Function} cb  - function of form: (key, value) => [nextKey, nextValue]\n *  - the return type here is an array of two elements, key and value, where `key` must be either a string or a number\n *  - if a cb does not return an entry, then the original [key, value] pair that was passed into cb will be used instead\n * @example mapObj({a: 2, b: 3}, (k, v) => [k, v * v]) returns: {a: 4, b: 9}\n * @example mapObj({a: 1}, (k, v) => ['b', v]) returns: {b: 1}\n * @function\n *\n * @returns {Object} - new object with mapping applied, or the original obj if input was invalid\n */\nexport const mapEntries = (obj, cb) => {\n  if (!isArr(obj) && !isObj(obj)) {\n    console.error(obj, `Expected array or object for obj. Found ${typeof obj}`)\n    return obj\n  }\n\n  if (!isFunc(cb)) {\n    console.error(`Expected function for cb. Found ${typeof cb}`)\n    return obj\n  }\n\n  const entries = Object.entries(obj)\n\n  const initialValue = isArr(obj) ? [] : {}\n\n  return entries.reduce((obj, [ key, value ]) => {\n    const result = cb(key, value)\n    if (!isEntry(result)) {\n      console.error(\n        `Callback function must return entry. Found: ${result}. Using current entry instead.`\n      )\n      return set(obj, key, value)\n    }\n    return set(obj, result[0], result[1])\n  }, initialValue)\n}\n","/** @module Object */\n\nimport { isObj } from './isObj'\nimport { isFunc } from '../method/isFunc'\nimport { mapEntries } from './mapEntries'\n\n/**\n * Shortcut helper for mapping just the keys of an object.\n * @function\n * @param {Object} obj - Object to have it's property keys mapped\n * @param {Function} keyMapper - Function of shape (key) => nextKey\n * @returns {Object} - The new object with each key mapped to the response of keyMapper\n */\nexport const mapKeys = (obj, keyMapper) => {\n  if (!isObj(obj) || !isFunc(keyMapper)) return obj\n\n  return mapEntries(obj, (key, value) => [ keyMapper(key), value ])\n}\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { isObj } from './isObj'\n\n/**\n * Map over and objects props and values.\n * @function\n * @param {Object} obj - Object to map over\n * @param {Function} cb - Method to call for each entry in the passed in obj\n * @return {Array} -  returned values from callback || The entries of the passed in obj\n */\nexport const mapObj = (obj, cb) => {\n  if (!isObj(obj)) return []\n\n  const entries = Object.entries(obj)\n  return isFunc(cb) ? entries.map(([ key, value ]) => cb(key, value)) : entries\n}\n","/** @module Object */\n\nimport { isObj } from './isObj'\nimport { reduceObj } from './reduceObj'\n\n/**\n * Creates a new object from passed in object with keys not defined from array.\n * @function\n * @param {Object} target - object to pull keys from\n * @param {Array} keys - keys to not add to new object\n * @return {Object} new object with only keys not in array\n */\nexport const omitKeys = (obj = {}, keys = []) =>\n  (isObj(obj) &&\n    reduceObj(\n      obj,\n      (key, _, updated) => {\n        keys.indexOf(key) === -1 && (updated[key] = obj[key])\n\n        return updated\n      },\n      {}\n    )) ||\n  {}\n","/** @module Object */\n\nimport { isObj } from './isObj'\n\n/**\n * Creates a new object from passed in object with keys defined from array.\n * @function\n * @param {Object} obj - object to pull keys from\n * @param {Array} keys - keys to add to new object\n * @return {Object} new object with only keys from passed in keys array\n */\nexport const pickKeys = (obj = {}, keys = []) =>\n  (isObj(obj) &&\n    keys.reduce((updated, key) => {\n      key in obj && (updated[key] = obj[key])\n\n      return updated\n    }, {})) ||\n  {}\n","/** @module Object */\n\nimport { sanitize } from '../string/sanitize'\n\n/**\n * Sanitizes all html strings in an object's properties.\n * @function\n * @param {Object} obj - Object to be sanitize\n * @return {Object} - obj with strings sanitized\n */\nexport const sanitizeCopy = obj => JSON.parse(sanitize(JSON.stringify(obj)))\n","/** @module Object */\n\nimport { isStr } from '../string/isStr'\n\n/**\n * Trims objects string fields.\n * @function\n * @param {Object} object\n * @return {Object} - object with string fields trimmed\n */\nexport const trimStringFields = object =>\n  Object.entries(object).reduce((cleaned, [ key, value ]) => {\n    cleaned[key] = isStr(value) ? value.trim() : value\n    return cleaned\n  }, object)\n","/** @module Object */\n\nimport { isStr } from '../string/isStr'\nimport { isArr } from '../array/isArr'\nimport { strToType } from '../ext/strToType'\n\n/**\n * Converts an array or string into an object.\n * @function\n * @param { array | string } val - to be converted to object\n * @param {String} [divider] - if string, what divides key from value\n * @param {String} [split] - if string, what splits each key/value pair\n * @return {Object} - Converted object\n */\nexport const toObj = (val, divider, split) => {\n  if (isArr(val))\n    return Object.keys(val).reduce((obj, key) => {\n      obj[key] = val[key]\n\n      return obj\n    }, {})\n\n  if (!isStr(val)) return {}\n\n  divider = divider || '='\n  split = split || '&'\n  return val\n    .toString()\n    .split(split)\n    .reduce((obj, item) => {\n      const sep = item.split(divider)\n      obj[sep[0].trim()] = strToType(sep[1].trim())\n\n      return obj\n    }, {})\n}\n","/** @module Object */\n\nimport { isStr } from '../string/isStr'\nimport { isArr } from '../array/isArr'\n\n/**\n * Converts an array of strings to a matching key/value pair object.\n * @function\n * @param {Array} arr - to be converted to object\n * @param {Boolean} toUpperCase - converts the key and value to uppercase\n * @return {Object} built object\n */\nexport const keyMap = (arr, toUpperCase) =>\n  (isArr(arr) &&\n    arr.reduce((obj, key) => {\n      if (!isStr(key)) return obj\n\n      const use = (toUpperCase && key.toUpperCase()) || key\n      obj[use] = use\n\n      return obj\n    }, {})) ||\n  {}\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { pipeline } from '../method/pipeline'\nimport { isObj } from './isObj'\n\n/**\n * Like \"every\" for arrays, but operates across each entry in an object\n * @function\n * @param {Object} obj - Object to the it's entries iterated on\n * @param {Function} predicate - Function of form (key, value) => boolean. Returns true or false for the entry\n * @param {Boolean} [logError=true] - Boolean indicating if errors should be logged\n * @returns {Boolean} - Boolean indicating that every entry satisfied the predicate or not\n */\nexport const everyEntry = (obj, predicate, logError = true) => {\n  if (!isObj(obj)) {\n    logError && console.error(`First argument ${obj} must be an object.`)\n    return false\n  }\n\n  if (!isFunc(predicate)) {\n    logError && console.error(`Second argument ${predicate}, must a function`)\n    return false\n  }\n\n  return pipeline(obj, Object.entries, entries =>\n    entries.every(([ key, value ]) => predicate(key, value))\n  )\n}\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { pipeline } from '../method/pipeline'\nimport { isObj } from './isObj'\n\n/**\n * Like \"some\" for arrays, but operates across each entry in obj\n * @function\n * @param {Object} obj - Object to have it's properties checked\n * @param {Function} predicate of form (key, value) => boolean. Returns true or false for the entry\n * @param {Boolean} [logError=true] - Boolean indicating if errors should be logged\n * @returns {Boolean} - True if at least one entry satisfied the predicate, false if not\n */\nexport const someEntry = (obj, predicate, logError = true) => {\n  if (!isObj(obj)) {\n    logError && console.error(`First argument ${obj} must be an object.`)\n    return false\n  }\n\n  if (!isFunc(predicate)) {\n    logError && console.error(`Second argument ${predicate}, must a function`)\n    return false\n  }\n\n  return pipeline(obj, Object.entries, entries =>\n    entries.some(([ key, value ]) => predicate(key, value))\n  )\n}\n","/** @module Object */\n\nimport { isFunc } from '../method/isFunc'\nimport { isObj } from './isObj'\nimport { reduceObj } from './reduceObj'\n\n/**\n * Returns a new object, consisting of every key-value pair from obj that, when passed into the predicate, returned true\n * @function\n * @param {Object} obj - Object that should have it's properties filtered\n * @param {Function} predicate  - function of form: (key, value) => Boolean\n * @param {Boolean} [logError=true] - Boolean indicating if errors should be logged\n * @returns {Object} - Object consisting of a subset of the entries from obj\n * @example: filterObj({a: 2, b: 3}, (k, v) => (v > 2)) returns: {b: 3}\n */\nexport const filterObj = (obj, predicate, logError = true) => {\n  if (!isObj(obj)) {\n    logError && console.error(`First argument ${obj} must be an object.`)\n    return obj\n  }\n\n  if (!isFunc(predicate)) {\n    logError && console.error(`Second argument ${predicate}, must a function`)\n    return obj\n  }\n\n  return reduceObj(\n    obj,\n    (key, value, data) => {\n      if (predicate(key, value)) data[key] = value\n      return data\n    },\n    {}\n  )\n}\n","/** @module Object */\n\nconst pad = (hash, len) => {\n  while (hash.length < len)\n    hash = '0' + hash\n\n  return hash\n}\n\nconst fold = (hash, text) => {\n  if (text.length === 0) return hash\n\n  let i;\n  let chr;\n  let len;\n\n  for (i = 0, len = text.length; i < len; i++) {\n    chr = text.charCodeAt(i)\n    hash = ((hash << 5) - hash) + chr\n    hash |= 0\n  }\n\n  return hash < 0 ? hash * -2 : hash\n}\n\nconst foldObject = (hash, obj, seen) => {\n  const foldKey = (hash, key) => foldValue(hash, obj[key], key, seen)\n\n  return Object.keys(obj).sort().reduce(foldKey, hash)\n}\n\nconst foldValue = (input, value, key, seen) => {\n  const hash = fold(fold(fold(input, key), toString(value)), typeof value)\n  \n  if (value === null) return fold(hash, 'null')\n\n  if (value === undefined) return fold(hash, 'undefined')\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    if (seen.indexOf(value) !== -1) return fold(hash, '[Circular]' + key)\n    \n    seen.push(value)\n\n    const objHash = foldObject(hash, value, seen)\n\n    if (!('valueOf' in value) || typeof value.valueOf !== 'function') objHash\n\n    try {\n      return fold(objHash, String(value.valueOf()))\n    }\n    catch (err) {\n      return fold(objHash, '[valueOf exception]' + (err.stack || err.message))\n    }\n\n  }\n\n  return fold(hash, value.toString())\n}\n\nconst toString = (obj) => Object.prototype.toString.call(obj)\n\n/**\n * Creates a consistent hash string from the passed in object\n * <br/>Not intended to be secure\n * <br/>Given the same input keys and values, it will always return the same output hash\n */\nexport const hashObj = (obj) => pad(foldValue(0, obj, '', []).toString(16), 8)\n\n","/** @module Object */\n\nimport { isObj } from './isObj'\nimport { exists } from '../ext/exists'\nimport { toStr } from '../string/toStr'\nimport { reduceObj } from './reduceObj'\nimport { ensureArr } from '../array/ensureArr'\n\n/**\n * Creates an intersection of the passed in object, based on the passed in keys\n * @function\n * @param {Object} target - object to pull keys from\n * @param {Array} keys - keys to not add to new object\n * @example\n * const [matching, nonMatching] = splitByKeys({ 1: 'match', 2: 'non-matching' }, [ 1 ])\n * matching === { 1: 'match' } === true\n * nonMatching === { 2: 'non-matching' }  === true\n *\n * @return {Array<Object>} - First object contains keys matching keys of the keys argument\n *                          - Second object contains keys not matching keys of the keys argument\n */\nexport const splitByKeys = (obj = {}, keys) => {\n  if (!keys) return [{}, { ...obj }]\n\n  const intersect = [{}, {}]\n  const compareKeys = ensureArr(keys)\n\n  return isObj(obj)\n    ? reduceObj(\n      obj,\n      (key, _, updated) => {\n        exists(compareKeys.find(k => exists(k) && toStr(k) === key))\n          ? (updated[0][key] = obj[key])\n          : (updated[1][key] = obj[key])\n\n        return updated\n      },\n      intersect\n    )\n    : intersect\n}\n","/** @module Object */\n\nimport { emptyObj } from '../ext/noOps'\n\n/**\n * Transforms the keys of an object to a matching key value in keyMap object\n * Keys not in the keyMap are included as is, unless strict === true option is passed\n * @example\n * transformKeys({my_key: `1234`, other_key: `4321`}, {my_key: `myKey`}) === { myKey: `1234`, other_key: `4321` }\n * @example\n * const opts = { strict: true }\n * transformKeys({my_key: `1234`, other_key: `4321`}, {my_key: `myKey`}, opts) === { myKey: `1234` }\n */\nexport const transformKeys = (\n  obj=emptyObj,\n  keyMap=emptyObj,\n  opts=emptyObj,\n) => {\n  const { strict=false  } = opts\n\n  return Object.entries(obj)\n    .reduce((acc, [key, value])=> {\n      const ref = keyMap[key] || (!strict ? key : undefined)\n      ref && (acc[ref] = value)\n\n      return acc\n    }, {})\n}","/** @module Promise */\n\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Converts a standard callback method into Promise\n * @param {Function} method - Function to convert into a promise\n * @function\n *\n * @return {Promise<Function>} - Passed in method converted into a promise\n */\nexport const promisify = method => {\n  if (!isFunc(method)) throw `Argument must be a function`\n\n  return (...args) => {\n    return new Promise((res, rej) => {\n      // If the last arg is not a function, just return the resolved method\n      if (!isFunc(args[args.length - 1])) return res(method(...args))\n\n      // Remove the callback method\n      args.pop()\n      // Replace it with the promise resolve / reject\n      args.push((...cbData) => {\n        // If the cbData first arg is not falsy, then reject the promise\n        // Otherwise resolve it\n        return cbData && cbData[0] ? rej(...cbData) : res(...cbData)\n      })\n\n      // Call the method, and return it\n      return method(...args)\n    })\n  }\n}\n","/** @module Promise */\n\nimport { isObj } from '../object/isObj'\nimport { isFunc } from '../method/isFunc'\nimport { promisify } from './promisify'\n\n/**\n * Creates an array of Object default properties not to convert into promises\n * @ignore\n */\nconst defObjProps = Array.from([\n  'caller',\n  'callee',\n  'arguments',\n  'apply',\n  'bind',\n  'call',\n  'toString',\n  '__proto__',\n  '__defineGetter__',\n  '__defineSetter__',\n  'hasOwnProperty',\n  '__lookupGetter__',\n  '__lookupSetter__',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'valueOf',\n  'toLocaleString',\n])\n  .concat(Object.getOwnPropertyNames(Object.prototype))\n  .reduce((map, functionName) => {\n    map[functionName] = true\n    return map\n  }, {})\n\n/**\n * Loops an object and looks for any methods that belong to the object, then add an Async version\n * @param {Object} object\n * @return {Object} - object with Async methods added\n * @private\n */\nconst addAsync = object => {\n  if (!object.__IS_PROMISIFIED__) {\n    for (const prop of Object.getOwnPropertyNames(object)) {\n      const isAsync = prop.indexOf('Async') !== -1 || object[`${prop}Async`]\n      if (isAsync || defObjProps[prop]) continue\n\n      if (isFunc(object[prop])) object[`${prop}Async`] = promisify(object[prop])\n      else {\n        const getValue = Object.getOwnPropertyDescriptor(object, prop).get\n        if (isFunc(getValue)) object[`${prop}Async`] = promisify(getValue)\n      }\n    }\n    object.__IS_PROMISIFIED__ = true\n  }\n\n  return object\n}\n\n/**\n * Converts Objects method properties into promiseAsync. allow using promisifyAll\n * @function\n * @param {Object} object\n * @return {Object} - promisified object\n */\nexport const promisifyAll = object => {\n  if (!isObj(object)) return object\n\n  addAsync(object)\n  const proto = Object.getPrototypeOf(object)\n\n  proto && Object.getPrototypeOf(proto) !== null && addAsync(proto)\n\n  return object\n}\n","/** @module Promise */\n\n'use strict'\n\n/**\n * Stops execution for a given amount of time\n * @function\n * @param {Number} time - Amount of time to wait\n * @return { void }\n */\nexport const wait = time =>\n  new Promise(res => setTimeout(() => res(true), time))\n","export enum EHookType {\n  beforeAll=`beforeAll`,\n  afterAll=`afterAll`,\n  beforeEach=`beforeEach`,\n  afterEach=`afterEach`\n}\n\nexport enum EStepType {\n  step=`step`,\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  \"*\"=`*`,\n}\n\nexport enum EStepMethodType {\n  Given=`Given`,\n  When=`When`,\n  Then=`Then`,\n  And=`And`,\n  But=`But`,\n  \"*\"=`*`,\n}\n\nexport enum EAstObject {\n  error=`error`,\n  tags=`tags`,\n  rule=`rule`,\n  rules=`rules`,\n  step=`step`,\n  steps=`steps`,\n  block=`block`,\n  blocks=`blocks`,\n  empty=`empty`,\n  reason=`reason`,\n  desire=`desire`,\n  comment=`comment`,\n  comments=`comments`,\n  feature=`feature`,\n  scenario=`scenario`,\n  scenarios=`scenarios`,\n  background=`background`,\n  perspective=`perspective`,\n\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  \"*\"=`*`,\n  \n  expression=`expression`,\n  expressions=`expressions`,\n}\n\nexport enum EFeatureTypes {\n  feature = `Feature`,\n  Feature = `Feature`,\n  FEATURE = `Feature`,\n  rule = `Rule`,\n  Rule = `Rule`,\n  background = `Background`,\n  Background = `Background`,\n  BACKGROUND = `Background`,\n  scenario = `Scenario`,\n  Scenario = `Scenario`,\n  SCENARIO = `Scenario`,\n  example = `Example`,\n  Example = `Example`,\n  EXAMPLE = `Example`,\n  step = `Step`,\n  Step = `Step`,\n  RULE = `Rule`,\n  STEP = `Step`\n}\n\nexport type TAnyFunc = (...args:any[]) => any\n","import { EAstObject, EStepType, EHookType } from './types'\nimport { deepFreeze } from '@keg-hub/jsutils'\n\nconst ignoreTypes = [\n  `*`,\n  ``,\n]\n\nexport const constants = deepFreeze({\n  ALIAS_REF: `$$`,\n  ALIAS_WORLD_KEY: `$alias`,\n  ALIAS_REF_AT_RUNTIME: `$$:`,\n  REGEX_VARIANT: 'regex',\n  WORLD_REF: `$`,\n  WORLD_KEY: `$world`,\n  WORLD_AT_RUNTIME: `$:`,\n  EXPRESSION_VARIANT: 'expression',\n  HOOK_TYPES: Object.keys(EHookType),\n  STEP_TYPES: Object.keys(EStepType).filter(type => !ignoreTypes.includes(type)),\n  FEATURE_META: [ 'feature', 'perspective', 'desire', 'reason', 'comments' ],\n  LOG_JEST_SPEC_ENV: `PARKIN_LOG_JEST_SPEC`,\n  SPEC_RESULT_LOG: `------- PARKIN SPEC RESULT LOG -------`,\n})\n\nexport const ParentTypes = [\n  EAstObject.rule,\n  EAstObject.scenario,\n  EAstObject.background,\n]\n\nexport const StepTypes = [\n  EAstObject.given,\n  EAstObject.when,\n  EAstObject.then,\n  EAstObject.and,\n  EAstObject.but,\n  EAstObject[`*`],\n  EAstObject.step,\n  EAstObject.steps,\n]\n\nexport const ParkinBailErrName = `ParkinBailError`\nexport const ParkinAbortErrName = `ParkinAbortError`","import {isStr} from '@keg-hub/jsutils'\nimport { ParkinAbortErrName, ParkinBailErrName } from '../constants'\nimport { EHookType, TRunResults } from '../types'\n\nconst resolveErrMsg = (error?:string|Error, maybe?:Error|string):[string, Error] => {\n  return isStr(error)\n    ? [error as string, maybe as Error]\n    : [((error || maybe) as Error)?.message, (error || maybe) as Error]\n}\n\nconst replaceStackMsg = (err:Error, msg:string) => {\n  const split = err.stack.split(`\\n`)\n  split[0] = msg\n\n  return split.join(`\\n`)\n}\n\nexport class ParkinError extends Error {\n  name = `ParkinError`\n  results?:TRunResults\n  testResults?:TRunResults\n\n  constructor(msg:string|Error, error?:string|Error|ParkinError, replaceStack:boolean=true){\n    const [message, err] = resolveErrMsg(msg, error)\n    const { stackTraceLimit } = Error\n    if(err && replaceStack){\n      // Create a new error without a stacktrace\n      Error.stackTraceLimit = 0\n    }\n\n    // Set the error cause if it's different form the message\n    const opts = err && message !== err?.message\n      ? { cause: err?.message }\n      : undefined\n\n    super(message, opts)\n\n    this.results = (err as ParkinError)?.results || []\n    this.testResults = (err as ParkinError)?.testResults || []\n\n    if((err as any)?.result && !this.results.includes((err as any).result))\n      this.results.push((err as any).result)\n\n    // Reset the original stacktrace limit\n    Error.stackTraceLimit = stackTraceLimit\n    this.name = this.constructor.name\n    \n    if(replaceStack){\n      if(err?.stack) this.stack = replaceStackMsg(err, message)\n      err && Error.captureStackTrace(err, this.constructor)\n    }\n  }\n}\n\nexport class ParkinBailError extends ParkinError {\n  name = ParkinBailErrName\n  constructor(msg:string|Error, error?:string|Error, replaceStack:boolean=true){\n    super(msg, error, replaceStack)\n  }\n}\n\nexport class ParkinAbortError extends ParkinError {\n  name = ParkinAbortErrName\n  constructor(msg:string|Error, error?:string|Error, replaceStack:boolean=true){\n    super(msg, error, replaceStack)\n  }\n}\n\nexport class RetryError extends Error {\n  results?:TRunResults\n  constructor(err:Error, message?:string, retry?:number) {\n    super(message || err.message)\n    this.stack = err.stack\n    // Only overwrite the default Error name when retry was actually set\n    // Keep custom named errors incase they are depended on\n    this.name = !retry ? err.name : this.constructor.name\n\n    if(message) this.cause = err.message\n    if((err as RetryError).results) this.results = (err as RetryError).results\n  }\n}\n\n/*\n * Helper method to use throw a Parkin Bail error\n * @function\n * @public\n * @throws\n *\n */\nexport const throwAbortError = (err?:Error) => {\n  throw new ParkinAbortError(\n    `Test execution \\x1b[33m\"aborted\"\\x1b[0m`,\n    err,\n    true\n  )\n}\n\n/*\n * Helper method to use throw a Parkin Bail error\n * @function\n * @public\n * @throws\n *\n */\nexport const throwBailError = (err:Error, bail?:number) => {\n  const colored = `\\x1b[33m${bail}\\x1b[0m`\n  throw new ParkinBailError(\n    `Stopping test execution. Max allowed failed${bail ? ` ${colored} ` : ` `}tests has been reached`,\n    err,\n    true\n  )\n}\n\nexport const throwExitOnFailed = (err:Error) => {\n  throw new ParkinBailError(\n    `Stopping test execution. A test failed and \\x1b[33m\"exitOnFailed\"\\x1b[0m is active`,\n    err,\n    true\n  )\n}\n\n/*\n * Helper method to use the a test method can not be found on the global scope\n * @function\n * @public\n * @throws\n *\n */\nexport const testMethodFill = (type:string) => {\n  /*\n   * Internal method that throws an error when a test method does not exist on the global scope\n   * @function\n   * @private\n   * @inner\n   *\n   */\n  return () => {\n    throw new ParkinError(\n      `` +\n        `Test method ${type} does not exist on the global scope.\\n` +\n        `Please ensure ${type} exists before calling the run method!\\n`\n    )\n  }\n}\n\n/**\n * Throws an error when a Steps class instance is not passed to the runner class constructor\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingSteps = () => {\n  throw new ParkinError(\n    `Runner class constructor requires an instance of the Steps class`\n  )\n}\n\n/**\n * Throws an error when a Hooks class instance is not passed to the runner class constructor\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingHooks = (found:any) => {\n  throw new ParkinError(\n    `Runner class constructor requires an instance of the Hooks class. Found: ${found}`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingFeatureText = () => {\n  throw new ParkinError(\n    `Runner class requires feature text when calling the run method`\n  )\n}\n\n/**\n * Throws an error when a feature step does not match a step definition\n * @function\n * @public\n * @throws\n *\n */\nexport const throwNoMatchingStep = (text:string) => {\n  throw new ParkinError(text)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @throws\n *\n */\nexport const throwParamTypeExists = (name:string) => {\n  throw new ParkinError(`Cannot register param type \"${name}\". It already exists!`)\n}\n\n/**\n * Throws an error when a assembling a parsed feature, and no parsed feature object exists\n * @function\n * @public\n * @throws\n * \n */\nexport const throwFeatureNotAnObj = (feature:any) => {\n  throw new ParkinError(`Assemble feature requires an object matching the feature model spec!`)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingWorldValue = (arg:string) => {\n  throw new ParkinError(\n    `Can not replace ${arg} with value from $world, it does not exist on the world object`,\n  )\n}\n\n/**\n * Throws an error when a registering an invalid hook type\n * @function\n * @public\n * @throws\n *\n */\nexport const throwInvalidHookType = (hookTypes:EHookType, type:string) => {\n  throw new ParkinError(\n    [\n      `Expected client hook type to be one of ', ${hookTypes}.`,\n      `Found: ${type}`,\n    ].join('\\n')\n  )\n}\n\n/**\n * Throws an error when running world replace on feature text content\n * @function\n * @public\n * @throws\n *\n */\nexport const throwWorldReplace = (err:Error, currentMatch:string) => {\n  throw new ParkinError(`Error replacing $world value in feature text. Current match was ${currentMatch}`, err)\n}\n\n/**\n * Throws an error when running world.alias replace on feature text content\n * @function\n * @public\n * @throws\n *\n */\nexport const throwAliasReplace = (err:Error, currentMatch:string) => {\n  throw new ParkinError(\n    `Error replacing $$alias ( $world.$alias ) in feature text. Current match was ${currentMatch}`,\n    err\n  )\n}\n","import type {\n  TType,\n  TTestObj,\n  THookTypes,\n  TTestAction,\n  TRootTestObj,\n  TGlobalTypes,\n  TTestHookMethod,\n  TDescribeAction,\n  TDescribeTestObj,\n} from '../types'\n\nimport { ParkinError } from '../utils/errors'\nimport { keyMap, isFunc, isStr, noOpObj } from '@keg-hub/jsutils'\n\n/**\n * @type {Object}\n * Key value pair of all helper method names for the ParkinTest Class\n */\nexport const hookTypes = keyMap<THookTypes>([\n  `beforeAll`,\n  `beforeEach`,\n  `afterAll`,\n  `afterEach`,\n])\n\n/**\n * @type {Object}\n * Key value pair of all methods added to the global scope\n */\nexport const globalTypes:TGlobalTypes = {\n  ...keyMap([ `test`, `it`, `xtest`, `xit`, `describe` ]),\n  ...hookTypes,\n}\n\n/**\n * @type {Object}\n * Key value pair of allowed Types for the ParkinTest Class\n */\nexport const Types:TType = {\n  ...globalTypes,\n  ...keyMap([`root`]),\n}\n\n/**\n * Adds the class instance methods to the global scope\n * @param {Object} instance - An instance of the ParkinTest Class\n *\n * @returns void\n */\nexport const addToGlobal = (instance:TTestObj) => {}\n\n/**\n * Throws an Error from the passed in error\n * @param {string} error - The Error message or Object to throw\n *\n * @throws\n */\nexport const throwError = (error:string) => {\n  throw new ParkinError(error)\n}\n\n/**\n * Validates the required arguments were passed in of a helper method\n * @throws\n *\n */\nexport const validateHook = (\n  type:keyof typeof Types,\n  action:TTestHookMethod,\n) => {\n  !isFunc(action) &&\n    throwError(\n      `The ${type} method requires a \"function\" as the first argument`\n    )\n}\n\nexport const validateRootRun = (root:TRootTestObj) => {\n  root.type !== Types.root &&\n    throwError(`Invalid root type \"${root.type}\" set for root object`)\n  !root.describes ||\n    (!root.describes.length &&\n      throwError(`No tests have been registered to this ParkinTest instance`))\n}\n\n/**\n * Validates the required arguments were passed in\n * @throws\n *\n */\nexport const validateItem = (\n  type:string,\n  description:string,\n  action:TTestAction|TDescribeAction\n) => {\n  !isStr(type) && throwError(`Test item type is required as a string`)\n  !isFunc(action) &&\n    throwError(\n      `The ${type} method requires a \"function\" as the second argument`\n    )\n  !isStr(description) &&\n    throwError(`The ${type} method requires a \"string\" as the first argument`)\n}\n\n/**\n * Creates an object with meta data of an item of the ParkinTest instance\n *\n */\nexport const createItem = <T=TTestObj>(\n  type:string,\n  metadata:Partial<TTestObj> = noOpObj as TTestObj,\n  validate = true\n) => {\n  const { description, action } = metadata\n  validate && validateItem(type, description, action)\n\n  return { ...metadata, type } as T\n}\n\n/**\n * Creates a describe object for the passed in description and action\n *\n */\nexport const createDescribe = (\n  description:string,\n  action:TDescribeAction\n) => {\n  const item = createItem(Types.describe, {\n    ...createRoot(),\n    action,\n    tests: [],\n    description,\n  }) as TDescribeTestObj\n\n  item.disabled = () => (item.skip = true)\n\n  return item\n}\n\n/**\n * Creates a root object\n *\n */\nexport const createRoot = () => {\n  return createItem(\n    Types.root,\n    {\n      describes: [],\n      ...Object.values(hookTypes).reduce((acc, type) => {\n        acc[type] = []\n        return acc\n      }, {}),\n    },\n    false\n  ) as TRootTestObj\n}\n","import type {\n  TTestObj,\n  TRunResult,\n  TRunResultTestMeta\n} from '../types'\nimport { EResultStatus } from '../types'\nimport { isObj } from '@keg-hub/jsutils'\n\n\n/**\n * Builds a test run result base on the passed in arguments\n *\n */\nexport const runResult = (\n  item:TTestObj,\n  {\n    id,\n    tests,\n    stats,\n    action,\n    failed,\n    passed,\n    testPath,\n    fullName,\n    describes,\n  }:TRunResultTestMeta\n) => {\n\n  const result:TRunResult = {\n    id,\n    stats,\n    action,\n    testPath,\n    fullName,\n    type: item.type,\n    failedExpectations: [],\n    passedExpectations: [],\n    failed: Boolean(failed),\n    passed: Boolean(passed),\n    description: item.description,\n    timestamp: new Date().getTime(),\n  }\n\n  if(tests?.length) result.tests = tests\n  if(describes?.length) result.describes = describes\n\n  isObj(failed) && result.failedExpectations.push(failed)\n  isObj(passed) && result.passedExpectations.push(passed)\n\n  isObj(item?.action?.ParkinMetaData)\n    ? (result.metaData = item?.action?.ParkinMetaData)\n    : isObj(item?.action?.metaData)\n        && (result.metaData = item?.action?.metaData)\n\n  if (passed || failed)\n    result.status = passed\n      ? EResultStatus.passed\n      : result?.metaData?.warnOnFailed\n        ? EResultStatus.warning\n        : EResultStatus.failed\n\n  return result\n}\n","import type {\n  TType,\n  TTestStats,\n  TRunResult,\n  TRootTestObj,\n  TTestTestObj,\n  TParkinHookCB,\n  TDescribeTestObj,\n} from '../types'\n\n\nimport { Types } from './utils'\nimport { runResult } from './runResult'\nimport { EResultStatus, EResultAction, ETestType } from '../types'\n\ntype TLoopHooks = {\n  test?:TTestTestObj\n  type: keyof TType\n  stats:TTestStats\n  describe?:TDescribeTestObj\n  specId?:keyof TType|string\n  suiteId?:keyof TType|string\n  root?: TRootTestObj|TDescribeTestObj\n}\n\nexport type TDescribeHooks = {\n  suiteId:string\n  stats:TTestStats\n  type:`before`|`after`\n  describe:TDescribeTestObj\n  describeResult:TRunResult\n  root:TDescribeTestObj | TRootTestObj\n  onSuiteDone:(result: TRunResult) => void\n}\n\n/**\n * Helper to loop over hooks and call them\n * @param {Object} args - Data for calling the passed in hook by type\n *\n * @returns {Object} - Built run result object if a hook fails\n */\nexport const loopHooks = async (args:TLoopHooks) => {\n  const {\n    type,\n    test,\n    root,\n    stats,\n    specId,\n    suiteId,\n    describe,\n  } = args\n\n  let hookResults:TRunResult[] = []\n\n  let hookIdx\n  const activeItem = root || describe\n  const fullName = root\n    ? root.description\n    : test\n      ? `${describe?.description} > ${test?.description} > ${type}`\n      : `${describe?.description} > ${type}`\n\n\n  activeItem[type].length &&\n    await Promise.all(\n      activeItem[type].map(async (fn:TParkinHookCB, idx:number) => {\n        hookIdx = idx\n        return await Promise.resolve()\n          .then(() => fn?.())\n          .catch((error:Error) => {\n            hookResults.push(\n              runResult(activeItem, {\n                stats,\n                fullName,\n                action: type as EResultAction,\n                id: test ? specId : suiteId,\n                status: EResultStatus.failed,\n                failed: {\n                  error,\n                  fullName,\n                  description: error.message,\n                  status: EResultStatus.failed,\n                },\n                testPath: test\n                  ? `/${suiteId}/${specId}/${type}${hookIdx}`\n                  : `/${suiteId}/${type}${hookIdx}`,\n              })\n            )\n          })\n      })\n    )\n\n  return hookResults\n}\n\n\n/**\n * Helper to call the before hooks from the root and current describe\n * @param {Object} args - Arguments needed to call the before hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nconst callBeforeHooks = async ({ root, suiteId, describe, stats }) => {\n  const beforeEachResult = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.beforeEach,\n  })\n\n  const beforeAllResult = await loopHooks({\n    stats,\n    suiteId,\n    describe,\n    type: Types.beforeAll,\n  })\n\n  return [...beforeEachResult, ...beforeAllResult]\n}\n\n/**\n * Helper to call the after hooks from the root and current describe\n * @param {Object} args - Arguments needed to call the after hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nconst callAfterHooks = async ({ root, suiteId, describe, stats }) => {\n  const afterEachResult = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.afterEach,\n  })\n\n  const afterAllResult = await loopHooks({\n      stats,\n      suiteId,\n      describe,\n      type: Types.afterAll,\n    })\n\n  return [...afterEachResult, ...afterAllResult]\n}\n\n\n/**\n * Helper to call the before and after hooks for describe methods\n * @param {Object} args - Arguments needed to call the after hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nexport const callDescribeHooks = async (args:TDescribeHooks) => {\n  const {\n    root,\n    type,\n    stats,\n    suiteId,\n    describe,\n    onSuiteDone,\n    describeResult\n  } = args\n\n  const results:TRunResult[] = []\n\n  const hooksResults = type === `before`\n    ? await callBeforeHooks({root, suiteId, describe, stats })\n    : await callAfterHooks({root, suiteId, describe, stats })\n  \n  if(!hooksResults?.length) return results\n  \n  if (hooksResults?.length) {\n    const describeResults = await Promise.all(\n      hooksResults.map(async (result) => {\n        const joined = {...describeResult, ...result, failed: true, passed: false }\n        await onSuiteDone(joined)\n\n        return joined\n      })\n    )\n\n    results.push(...describeResults)\n  }\n\n  return results\n}","import { wait } from \"@keg-hub/jsutils\"\nimport { TPromiseRetry } from \"../types\"\nimport { RetryError, throwAbortError } from './errors'\n\n// import { TAbortPromise } from \"../types\"\n// import { PromiseAbort } from './promiseAbort'\n// ----- Uncomment to add a PromiseAbort wrapper -----\n// Still working out how to do this properly, needs some work\n// export const PromiseRetry = <T=any>(opts:TPromiseRetry<T>): TAbortPromise<T> => {\n//   return PromiseAbort({\n//     promise: (args) => loopRetry({...opts, ...args}, opts?.retry || 0)\n//   })\n// }\n\nconst loopRetry = async <T=any>(opts:TPromiseRetry<T>, orgRetry?:number): Promise<T> => {\n  const {\n    delay=0,\n    retry=0,\n    onRetry,\n    controller,\n    promise:fn,\n    shouldAbort,\n  } = opts\n\n  const signal = controller?.signal\n\n  try {\n    const resp = await fn(opts)\n    return signal?.aborted || shouldAbort?.()\n      ?  throwAbortError()\n      : resp\n  }\n  catch (err) {\n    if(signal?.aborted || shouldAbort?.()) return throwAbortError()\n\n    if (retry <= 0) throw new RetryError(err, opts?.error, orgRetry)\n\n    const next = {...opts, retry: retry - 1}\n    onRetry && await onRetry?.(next)\n    delay && await wait(delay)\n\n    return loopRetry(next, orgRetry)\n  }\n}\n\nexport const PromiseRetry = async <T=any>(opts:TPromiseRetry<T>): Promise<T> => loopRetry(\n  opts,\n  opts?.retry || 0\n)\n\n","import { TPromiseTimeout } from \"../types\"\n\nclass TimeoutError extends Error {\n  constructor(message:string, name?:string) {\n    super(message)\n    this.name = name || this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n\nexport const PromiseTimeout = async <T=any>({\n  name,\n  error,\n  promise,\n  timeout=5000,\n}:TPromiseTimeout<T>):Promise<T> => {\n  const method = name ? `${name} method` : `method`\n\n  let timer:NodeJS.Timeout\n  const timePromise = new Promise((res, rej) => {\n    timer = setTimeout(() => rej(\n      new TimeoutError(\n        error || `The ${method} timed out after ${timeout} ms.`,\n        `TimeoutError`\n      )\n    ), timeout)\n  })\n\n  return await Promise.race([promise, timePromise] as [Promise<T>, Promise<any>])\n    .finally(() => clearTimeout(timer))\n}\n","import type { TPromiseRetry, TRunResult, TTestTestObj } from \"src/types\"\n\nimport { throwAbortError } from '../utils/errors'\nimport { PromiseRetry } from '../utils/promiseRetry'\nimport { PromiseTimeout } from '../utils/promiseTimeout'\n\nexport type TRunTest = Omit<TPromiseRetry<TRunResult>, `promise`> & {\n  test:TTestTestObj\n  shouldAbort:() => boolean\n}\n\n/**\n * Wraps the test.action in a Promise timeout and a Promise retry\n * Promise retry wraps the timeout, so each retry gets the same amount of time to resolve\n */\nexport const runTest = async (args:TRunTest) => {\n  const {test, shouldAbort, ...rest} = args\n\n  return PromiseRetry({\n    ...rest,\n    retry: test.retry || rest.retry || 0,\n    promise: async () => {\n      const promise = test.action()\n      shouldAbort() && throwAbortError()\n\n      /**\n        * If there is a timeout, Use the PromiseTimeout to race it against the test action\n        * If the timeout wins, it will reject the promise\n        * Which then gets picked up in the catch below\n        */\n      return test.timeout\n        ? await PromiseTimeout<TRunResult>({\n            promise,\n            timeout: test.timeout,\n            name: test.description,\n            error: `Test failed, the timeout ${test.timeout}ms was exceeded`\n          })\n        : await promise\n    }\n  })\n\n}","import type {\n  TTestTestObj,\n  TDescribeTestObj,\n} from \"../types\"\n\nexport type TShouldSkipTest = {\n  testOnly?:boolean\n  test: TTestTestObj\n  hasFailed?:boolean\n  skipAfterFailed?:boolean\n}\n\nexport type TBuildTestArgs = {\n  suiteId:string\n  testIdx:number\n  describe:TDescribeTestObj\n}\n\nexport type TShouldSkipDescribe = {\n  testOnly?:boolean\n  describeOnly?:boolean\n  describe: TDescribeTestObj\n}\n\n\nexport const shouldSkipTest = (params:TShouldSkipTest) => {\n  const {\n    test,\n    testOnly,\n    hasFailed,\n    skipAfterFailed\n  } = params\n\n  return test.skip\n    || (testOnly && !test.only)\n    || (hasFailed && skipAfterFailed)\n}\n\nexport const buildTestArgs = ({\n  suiteId,\n  testIdx,\n  describe\n}:TBuildTestArgs) => {\n  const test = describe.tests[testIdx]\n  const specId = `spec-${testIdx}`\n\n  return {\n    test,\n    specId,\n    testPath: `/${suiteId}/${specId}`,\n    fullName: `${describe.description} > ${test.description}`,\n  }\n}\n\n\nexport const shouldSkipDescribe = ({ describe, describeOnly, testOnly }:TShouldSkipDescribe) => {\n  return describe.skip ||\n    (describeOnly && !describe.only && !describe.onlyChild) ||\n    (testOnly && !describe.onlyChild)\n}","import type { TLoopTests, TRunResult, TRunResults } from '../types'\n\nimport { Types } from './utils'\n\nimport { runTest } from './runTest'\nimport { loopHooks } from './hooks'\nimport { runResult } from './runResult'\nimport { ParkinAbortErrName } from '../constants'\nimport { throwAbortError } from '../utils/errors'\nimport { EResultStatus, EResultAction } from '../types'\nimport { throwBailError, throwExitOnFailed } from '../utils/errors'\n\nimport {\n  buildTestArgs,\n  shouldSkipTest,\n} from './runHelpers'\n\n\n/**\n * Helper to loop over tests and call their test method\n *\n * @returns {Object} - Built run result object of the test results\n */\nexport const loopTests = async (args:TLoopTests) => {\n  const {\n    bail,\n    stats,\n    suiteId,\n    describe,\n    testOnly,\n    onSpecDone,\n    testRetry,\n    onTestRetry,\n    shouldAbort,\n    onSpecStart,\n    exitOnFailed,\n    skipAfterFailed,\n  } = args\n\n  let testsFailed = false\n  const results:TRunResults = []\n\n  // ------ describe - loop tests ------ //\n  for (let testIdx = 0; testIdx < describe.tests.length; testIdx++) {\n\n    shouldAbort() && throwAbortError()\n\n    const {\n      test,\n      specId,\n      testPath,\n      fullName,\n    } = buildTestArgs({ suiteId, testIdx, describe })\n\n    let testResult = runResult(test, {\n      stats,\n      fullName,\n      testPath,\n      id: specId,\n      action: EResultAction.start,\n    })\n\n    const shouldSkip = shouldSkipTest({\n      test,\n      testOnly,\n      skipAfterFailed,\n      hasFailed: testsFailed\n    })\n\n    if(shouldSkip){\n      const skipped = {\n        ...testResult,\n        skipped: true,\n        action: EResultAction.skipped,\n        status: EResultStatus.skipped,\n      }\n\n      await onSpecStart(skipped)\n      results.push(skipped)\n      continue\n    }\n    else await onSpecStart(testResult)\n\n    shouldAbort() && throwAbortError()\n\n    const beforeEachResults = await loopHooks({\n      test,\n      stats,\n      specId,\n      suiteId,\n      describe,\n      type: Types.beforeEach,\n    })\n\n    if (beforeEachResults?.length) {\n      testsFailed = true\n      results.push(...beforeEachResults)\n      beforeEachResults.forEach(onSpecDone)\n      break\n    }\n\n    // ------ execute test ------ //\n    try {\n\n      /**\n       * If there is a timeout, Use the PromiseTimeout to race it against the test action\n       * If the timeout wins, it will reject the promise\n       * Which then gets picked up in the catch below\n       */\n      const result = await runTest({\n        test,\n        shouldAbort,\n        retry: testRetry,\n        onRetry: onTestRetry,\n      })\n      \n      shouldAbort() && throwAbortError()\n\n      // If we get to here, the test passed, so up the passed spec count\n      stats.passedSpecs += 1\n\n      testResult = runResult(test, {\n        stats,\n        fullName,\n        id: specId,\n        testPath: testPath,\n        passed: result || true,\n        action: EResultAction.test,\n      })\n\n    }\n    catch (error) {\n\n      if(error.name === ParkinAbortErrName) throw error\n\n      testsFailed = true\n      stats.failedSpecs += 1\n\n      testResult = runResult(test, {\n        stats,\n        fullName,\n        id: specId,\n        testPath: testPath,\n        action: EResultAction.test,\n        failed: {\n          error,\n          fullName,\n          description: error.message,\n          status: EResultStatus.failed,\n        },\n      })\n\n      const shouldBail = Boolean(bail && stats.failedSpecs >= bail)\n      if(exitOnFailed || shouldBail){\n        results.push(testResult)\n        error.testResults = results\n        await onSpecDone(testResult)\n\n        exitOnFailed && throwExitOnFailed(error)\n        shouldBail && throwBailError(error, bail)\n        break\n      }\n\n    }\n    \n    shouldAbort() && throwAbortError()\n\n    const afterEachResults = await loopHooks({\n      test,\n      stats,\n      specId,\n      suiteId,\n      describe,\n      type: Types.afterEach,\n    })\n    if (afterEachResults?.length) {\n      testsFailed = true\n      results.push(...afterEachResults)\n      afterEachResults.forEach(onSpecDone)\n      break\n    }\n\n    results.push(testResult)\n\n    await onSpecDone({\n      ...testResult,\n      action: EResultAction.end\n    })\n\n  }\n\n  shouldAbort() && throwAbortError()\n\n  return { tests: results, failed: testsFailed }\n\n}\n","import type {\n  TRun,\n  TRunResult,\n  TTestStats,\n  TRunResults,\n  TParkinTestCB,\n  TDescribeTestObj,\n} from '../types'\n\nimport { runResult } from './runResult'\nimport { loopTests } from './loopTests'\nimport { callDescribeHooks } from './hooks'\nimport { ParkinAbortErrName } from '../constants'\nimport { shouldSkipDescribe } from './runHelpers'\nimport { EResultStatus, EResultAction } from '../types'\n\nexport type TLoopChildren<T=any> = {\n  stats:TTestStats\n  describeResult:TRunResult\n  onSuiteDone:TParkinTestCB\n  describe:TDescribeTestObj\n  loopFun:() => Promise<{tests?: TRunResults, describes?: TRunResults, failed: boolean }>\n}\n\n/**\n * Helper method to loop over children of a describe test object\n */\nconst loopChildren = async (args:TLoopChildren) => {\n  const {\n    stats,\n    describe,\n    onSuiteDone,\n    describeResult,\n    loopFun,\n  } = args\n\n  try {\n    const results = await loopFun()\n    const failed = results?.failed || describeResult?.failed\n\n    const joined = {\n      ...describeResult,\n      ...results,\n      action: EResultAction.end,\n    }\n    if(failed) joined.failed = failed\n\n    return joined\n  }\n  /**\n    * This will catch if an error is thrown by something other then a test or a hook\n    * For example Parkin Bail Error, or Parkin abort error is thrown, then it will show up here\n    * For abort errors we just rethrow the error, but for Bail errors\n    * We capture it so we can still call the onSuiteEnd callback, then rethrow the error\n    */\n  catch(err){\n    if(err.name === ParkinAbortErrName) throw err\n\n    stats.failedSuites += 1\n    const errorResult = runResult(describe, {\n      ...describeResult,\n      stats,\n      action: EResultAction.end,\n      failed: {\n        error: err,\n        description: err.message,\n        status: EResultStatus.failed,\n        fullName: describe.description,\n      }\n    })\n\n    // If there's testsResults\n    // Store them in the describe result, and remove them from the error\n    if(err.testResults){\n      errorResult.tests = err.testResults\n      err.testResults = undefined\n    }\n\n    await onSuiteDone(errorResult)\n\n    err.results = err.results || []\n    err.results.push(errorResult)\n\n    throw err\n  }\n\n}\n\n/**\n * Helper to loop over describe methods and call child tests\n * @param {Object} args - Config to overwrite the initial test config object\n *\n * @returns {Object} - Built run results of the test results\n */\nexport const loopDescribes = async (args:TRun) => {\n  const {\n    root,\n    bail,\n    stats,\n    testOnly,\n    testRetry,\n    onSpecDone,\n    onSuiteDone,\n    shouldAbort,\n    onTestRetry,\n    onSpecStart,\n    onSuiteStart,\n    describeOnly,\n    parentIdx = ``,\n    exitOnFailed,\n    skipAfterFailed,\n  } = args\n\n  let describeFailed = false\n  const results:TRunResults = []\n\n\n  // ------ loop describes ------ //\n  for (let idx = 0; idx < root.describes.length; idx++) {\n\n    if(shouldAbort()) break\n\n    const describe = root.describes[idx]\n    const suiteId = `suite-${parentIdx}${idx}`\n\n    // Create a runResult with general information that can be reused below\n    let describeResult = runResult(describe, {\n      stats,\n      id: suiteId,\n      testPath: `/${suiteId}`,\n      action: EResultAction.start,\n      fullName: describe.description,\n    })\n\n\n    if (shouldSkipDescribe({ describe, describeOnly, testOnly })) {\n      await onSuiteStart({\n        ...describeResult,\n        skipped: true,\n        action: EResultAction.skipped,\n        status: EResultStatus.skipped,\n      })\n      continue\n    }\n    else await onSuiteStart(describeResult)\n\n    const beforeResults = await callDescribeHooks({\n      root,\n      stats,\n      suiteId,\n      describe,\n      onSuiteDone,\n      describeResult,\n      type: `before`,\n    })\n\n    if (beforeResults?.length) {\n      describeFailed = true\n      results.push(...beforeResults)\n      continue\n    }\n\n    if(shouldAbort()) break\n\n    // Loop over any test children\n    describeResult = describe?.tests?.length\n      ? await loopChildren({\n          stats,\n          describe,\n          onSuiteDone,\n          describeResult,\n          loopFun: async () => await loopTests({\n            bail,\n            stats,\n            suiteId,\n            describe,\n            testOnly,\n            onSpecDone,\n            testRetry,\n            onTestRetry,\n            shouldAbort,\n            onSpecStart,\n            exitOnFailed,\n            skipAfterFailed,\n          })\n        })\n      : describeResult\n\n    if(exitOnFailed && describeResult.failed){\n      describeFailed = true\n      stats.failedSuites += 1\n      await onSuiteDone(describeResult)\n      results.push(describeResult)\n      break\n    }\n\n    // Loop over any describe children\n    describeResult = describe?.describes?.length\n      ? await loopChildren({\n          stats,\n          describe,\n          onSuiteDone,\n          describeResult,\n          loopFun: async () => await loopDescribes({\n            ...args,\n            root: describe,\n            parentIdx: `${idx}-`,\n          })\n        })\n      : describeResult\n\n    describeResult.failed\n      ? (stats.failedSuites += 1)\n      : (stats.passedSuites += 1)\n\n    if(exitOnFailed && describeResult.failed){\n      describeFailed = true\n      await onSuiteDone(describeResult)\n      results.push(describeResult)\n      break\n    }\n\n    if(shouldAbort()) break\n\n    if (describeResult.failed) {\n      describeFailed = true\n      describeResult.failed = true\n      describeResult.status = EResultStatus.failed\n    }\n    else {\n      describeResult.passed = true\n      describeResult.status = EResultStatus.passed\n    }\n\n    const afterResults = await callDescribeHooks({\n      root,\n      stats,\n      suiteId,\n      describe,\n      onSuiteDone,\n      describeResult,\n      type: `after`,\n    })\n\n    if (afterResults?.length) {\n      describeFailed = true\n      results.push(...afterResults)\n      continue\n    }\n\n    if(shouldAbort()) break\n\n    await onSuiteDone(describeResult)\n    results.push(describeResult)\n  }\n\n  return shouldAbort()\n    ? { describes: [], failed: describeFailed }\n    : { describes: results, failed: describeFailed }\n\n}\n","import type {\n  TRun,\n  TRunResults,\n  TRootTestObj,\n} from '../types'\n\nimport { loopHooks } from './hooks'\nimport { runResult } from './runResult'\n\nimport { ParkinError } from '../utils/errors'\nimport { ParkinBailErrName, ParkinAbortErrName } from '../constants'\nimport { loopDescribes } from './loopDescribes'\nimport { Types, validateRootRun } from './utils'\nimport { EResultStatus, EResultAction } from '../types'\n\n/**\n * Executes all methods registered to the ParkinTest instance\n * @param {Object} args - Config to overwrite the initial test config object\n *\n * @returns {Object} - Results of the test run\n */\nexport const run = async (args:TRun):Promise<TRunResults> => {\n  const {\n    root,\n    stats,\n    onAbort,\n    onRunDone,\n    shouldAbort,\n    onRunStart,\n  } = args\n\n  let bailError:ParkinError\n  let describesFailed:boolean\n  let describes:TRunResults = []\n\n\n  validateRootRun(root as TRootTestObj)\n  // Create a runResult with general information that can be reused below\n  let rootResult = runResult(root, {\n    stats,\n    id: Types.root,\n    fullName: root.description,\n    testPath: `/${Types.root}`,\n  })\n\n  await onRunStart({\n    ...rootResult,\n    stats,\n    action: EResultAction.start,\n    description: `Starting test execution`,\n  })\n\n  const beforeAllResults = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.beforeAll,\n  })\n\n  if(shouldAbort()){\n    await onAbort?.()\n    stats.runEnd = new Date().getTime()\n    await onRunDone({\n      ...rootResult,\n      stats,\n      action: EResultAction.abort,\n      description: `Test execution aborted`,\n    })\n\n    describes.aborted = true\n    return Object.assign(describes, stats)\n  }\n\n  // If a before all throws an error, we don't want to run the rest of the tests, so just return\n  if (beforeAllResults?.length) return Object.assign(beforeAllResults, stats)\n\n  // Ensure the afterAll hooks are always called\n  // Wrap the loopDescribes in a ty/catch/finally to ensure they are called at the end\n  try {\n    const resp = await loopDescribes(args)\n    describes = resp.describes\n    describesFailed = resp.failed\n\n    if(shouldAbort()){\n      await onAbort?.()\n      stats.runEnd = new Date().getTime()\n      await onRunDone({\n        ...rootResult,\n        stats,\n        action: EResultAction.abort,\n        description: `Test execution aborted`,\n      })\n      describes.aborted = true\n    }\n  }\n  catch(err){\n    describesFailed = true\n    const isBailErr = err.name === ParkinBailErrName\n    const isAbortErr = err.name === ParkinAbortErrName\n\n    bailError = isBailErr || isAbortErr ? err : undefined\n\n    if(isBailErr) describes.bailed = true\n    if(isAbortErr) describes.aborted = true\n\n    err.results\n      ? describes.push(...err.results)\n      : describes.push(runResult(root, {\n            stats,\n            describes,\n            id: Types.root,\n            fullName: root.description,\n            testPath: `/${Types.root}`,\n            action: EResultAction.end,\n            status: EResultStatus.failed,\n            failed: {\n              error: err,\n              description: err.message,\n              fullName: root.description,\n              status: EResultStatus.failed,\n            }\n        })\n      )\n\n  }\n  finally {\n    const afterAllResult = await loopHooks({\n      root,\n      stats,\n      suiteId: Types.root,\n      type: Types.afterAll,\n    })\n    afterAllResult?.length && describes.push(...afterAllResult)\n    stats.runEnd = stats.runEnd || new Date().getTime()\n\n    await onRunDone({\n      ...rootResult,\n      stats,\n      describes,\n      failed: describesFailed,\n      passed: !describesFailed,\n      action: EResultAction.end,\n      description: `Test execution complete`,\n      status: describesFailed ? EResultStatus.failed : EResultStatus.passed\n    })\n\n    if(bailError){\n      // After joining the error results with the already captured results\n      // Ensure the stats object is added as well\n      bailError.results = Object.assign(describes, stats)\n      throw bailError\n    }\n  }\n\n  return Object.assign(describes, stats)\n}\n","import type {\n  TRunResult,\n  TRunResults,\n  TTestAction,\n  TTestTestObj,\n  TParkinTestCB,\n  TParentTestObj,\n  TTestHookMethod,\n  TPromiseRetryCB,\n  TDescribeAction,\n  TParkinTestAbort,\n  TParkinTestConfig,\n  TParkinTestFactory,\n  TRunResultActionMeta,\n  TParkinDescribeFactory,\n} from '../types'\n\nimport { run } from './run'\nimport { runResult } from './runResult'\nimport { PromiseRetry } from '../utils/promiseRetry'\nimport { PromiseTimeout } from '../utils/promiseTimeout'\nimport { noOp, noOpObj, isStr, checkCall, isNum, isObj, exists } from '@keg-hub/jsutils'\nimport {\n  Types,\n  createRoot,\n  createItem,\n  createDescribe,\n  throwError,\n  hookTypes,\n  validateHook,\n} from './utils'\n\ntype TTestSkipFactory = (description:string, action?:TTestAction, timeout?:number) => void\n\nexport class ParkinTest {\n  // Defaults set to 0, is the same as disabled\n  bail = 0\n  testRetry = 0\n  suiteRetry = 0\n  #onTestRetry:TPromiseRetryCB<TRunResult>\n  #onSuiteRetry:TPromiseRetryCB<TRunResults>\n\n  // Default test timeout to be 5 seconds\n  testTimeout = 5000\n  // Default suite test timeout is 1hr\n  suiteTimeout = 3600000\n  #autoClean = true\n  #testOnly = false\n  #abortRun = false\n  #describeOnly = false\n  #exitOnFailed = false\n  #skipAfterFailed = false\n  #root = createRoot()\n  xit:TTestSkipFactory\n  it:TParkinTestFactory\n  #onRunDone:TParkinTestCB = noOp\n  #onRunStart:TParkinTestCB = noOp\n  #onSpecDone:TParkinTestCB = noOp\n  #onSuiteDone:TParkinTestCB = noOp\n  #onSpecStart:TParkinTestCB = noOp\n  #onSuiteStart:TParkinTestCB = noOp\n  #onAbort:TParkinTestAbort = noOp\n  afterAll:TTestHookMethod = noOp\n  afterEach:TTestHookMethod = noOp\n  beforeAll:TTestHookMethod = noOp\n  beforeEach:TTestHookMethod = noOp\n  #activeParent:TParentTestObj = undefined\n\n  constructor(config:TParkinTestConfig = noOpObj) {\n    this.#root.description = config.description || `root`\n\n    this.#addOnly()\n    this.#addSkip()\n    this.#addHelpers()\n    this.it = this.test\n    this.xit = this.xtest\n    this.#activeParent = this.#root\n    this.setConfig(config)\n  }\n\n  run = (config:TParkinTestConfig = noOpObj) => {\n\n    if (config.description) this.#root.description = config.description\n\n    this.setConfig(config)\n    const runSuite = async () => {\n      const promise = run({\n        bail: this.bail,\n        root: this.#root,\n        onAbort: this.#onAbort,\n        testOnly: this.#testOnly,\n        testRetry: this.testRetry,\n        onRunDone: this.#onRunDone,\n        onRunStart: this.#onRunStart,\n        onSpecDone: this.#onSpecDone,\n        onSpecStart: this.#onSpecStart,\n        onTestRetry: this.#onTestRetry,\n        shouldAbort: this.#shouldAbort,\n        onSuiteDone: this.#onSuiteDone,\n        onSuiteStart: this.#onSuiteStart,\n        exitOnFailed: this.#exitOnFailed,\n        describeOnly: this.#describeOnly,\n        skipAfterFailed: this.#skipAfterFailed,\n        stats: {\n          runEnd: 0,\n          failedSpecs: 0,\n          passedSpecs: 0,\n          passedSuites: 0,\n          failedSuites: 0,\n          runStart: new Date().getTime(),\n        },\n      })\n\n      const result = this.suiteTimeout\n        ? PromiseTimeout<TRunResults>({\n            promise,\n            timeout: this.suiteTimeout,\n            name: this.#root.description,\n            error: `Test Execution failed, the suite timeout ${this.suiteTimeout}ms was exceeded`\n          })\n        : promise\n\n      this.#autoClean && this.clean()\n\n      return result\n    }\n\n    return PromiseRetry({\n      promise: runSuite,\n      retry: this.suiteRetry,\n      onRetry: this.#onSuiteRetry\n    })\n  }\n\n  /**\n   * Expose the helper method to build a test result\n   * Helpful in cases where ParkinTest is wrapped by another tool\n   * Allows for a consistent iterface of events\n   */\n  buildResult = runResult\n\n  #shouldAbort = () => this.#abortRun\n\n  abort = () => {\n    this.#abortRun = true\n  }\n\n  /**\n   * Resets the instance to it's initial state\n   * Clears all previously loaded tests and describes\n   */\n  clean = () => {\n    this.testTimeout = 5000\n    this.suiteTimeout = 3600000\n    this.#autoClean = true\n    this.#abortRun = false\n    this.#testOnly = false\n    this.#describeOnly = false\n\n    this.#activeParent = undefined\n    this.#root = undefined\n    this.#root = createRoot()\n    this.#activeParent = this.#root\n  }\n\n  /**\n   * Gets the current activeParent, which should almost always be this.#root\n   */\n  getActiveParent = () => {\n    return this.#activeParent\n  }\n\n  /**\n   * Adds passed in framework hooks to the class instance\n   */\n  setConfig = ({\n    bail,\n    timeout,\n    testRetry,\n    suiteRetry,\n    testTimeout,\n    suiteTimeout,\n    onTestRetry,\n    onSuiteRetry,\n    exitOnFailed,\n    skipAfterFailed,\n    onAbort,\n    autoClean,\n    onSpecDone,\n    onSuiteDone,\n    onRunDone,\n    onRunStart,\n    onSpecStart,\n    onSuiteStart,\n  }:TParkinTestConfig=noOpObj) => {\n\n    if(onAbort) this.#onAbort = onAbort\n    \n    if(isNum(testTimeout)) this.testTimeout = testTimeout\n    else if(isNum(timeout)) this.testTimeout = timeout\n\n    if(isNum(suiteTimeout)) this.suiteTimeout = suiteTimeout\n    else if(isNum(timeout)) this.suiteTimeout = timeout\n\n    if (isNum(bail)) this.bail = bail\n    if (isNum(testRetry)) this.testRetry = testRetry\n    if (isNum(suiteRetry)) this.suiteRetry = suiteRetry\n\n    if (onTestRetry) this.#onTestRetry = onTestRetry\n    if (onSuiteRetry) this.#onSuiteRetry = onSuiteRetry\n\n    if (onSpecDone) this.#onSpecDone = onSpecDone\n    if (onSpecStart) this.#onSpecStart = onSpecStart\n\n    if (onSuiteDone) this.#onSuiteDone = onSuiteDone\n    if (onSuiteStart) this.#onSuiteStart = onSuiteStart\n\n    if (onRunDone) this.#onRunDone = onRunDone\n    if (onRunStart) this.#onRunStart = onRunStart\n\n    if (autoClean === false) this.#autoClean = autoClean\n\n    if(exitOnFailed) this.#exitOnFailed = exitOnFailed\n    if(skipAfterFailed) this.#skipAfterFailed = skipAfterFailed\n  }\n\n  /**\n   * Adds the only method to describe and test methods\n   * Ensures they are the only methods called when run\n   */\n  #addOnly = () => {\n\n    this.describe.only = (...args:[string, TDescribeAction]) => {\n      this.describe(...args)\n      // Get the last item just added to the this.#activeParent\n      const item =\n        this.#activeParent.describes[this.#activeParent.describes.length - 1]\n      item.only = true\n      this.#describeOnly = true\n      // Call the parent hasOnlyChild method to ensure it gets passed on the chain\n      checkCall(this.#activeParent.hasOnlyChild)\n    }\n\n    this.test.only = (...args:[description:string, action?:TTestAction, meta?:TRunResultActionMeta|number]) => {\n      this.test(...args)\n      // Get the last item just added to the this.#activeParent\n      const item = this.#activeParent.tests[this.#activeParent.tests.length - 1]\n      item.only = true\n      this.#testOnly = true\n      // Call the parent hasOnlyChild method to ensure it gets passed on the chain\n      checkCall(this.#activeParent.hasOnlyChild)\n    }\n  }\n\n  /**\n   * Adds the skip method to describe and test methods\n   * Ensures they are skipped run method is called\n   */\n  #addSkip = () => {\n\n    this.describe.skip = (...args:[string, TDescribeAction]) => {\n      this.describe(...args)\n      // Get the last item just added to the this.#activeParent\n      const item =\n        this.#activeParent.describes[this.#activeParent.describes.length - 1]\n      item.skip = true\n    }\n\n    this.test.skip = (...args:[description:string, action?:TTestAction, meta?:TRunResultActionMeta|number]) => {\n      this.test(...args)\n      // Get the last item just added to the this.#activeParent\n      const item = this.#activeParent.tests[this.#activeParent.tests.length - 1]\n      item.skip = true\n    }\n  }\n\n  /**\n   * TODO: @lance-Tipton\n   * Add each methods to describe and test\n   */\n  #addEach = () => {}\n\n  /**\n   * Adds the helper methods to the class instance\n   * Methods: beforeAll, beforeEach, afterAll, afterEach\n   */\n  #addHelpers = () => {\n    Object.values(hookTypes).map(type => {\n      this[type] = (action) => {\n        validateHook(type, action)\n        this.#activeParent[type].push(action)\n      }\n    })\n  }\n\n  /**\n   * Method the wraps test and helper methods\n   * Acts as a top level method for defining tests\n   *\n   * @returns {void}\n   */\n  describe = ((\n    description:string,\n    action:TDescribeAction\n  ) => {\n\n    // Build the describe item and add defaults\n    const item = createDescribe(description, action)\n    this.#activeParent.describes.push(item)\n\n    // Cache the lastParent, so we can reset it\n    const lastParent = this.#activeParent\n\n    item.hasOnlyChild = () => {\n      item.onlyChild = true\n      checkCall(lastParent.hasOnlyChild)\n    }\n\n    // Set the current activeParent to the item\n    this.#activeParent = item\n\n    // Call the action to register all test method calls while the items active\n    action()\n\n    // Reset the last activeParent\n    // Should end up with the #root being the final activeParent\n    this.#activeParent = lastParent\n  }) as TParkinDescribeFactory\n\n  /**\n   * Method that executes some test logic\n   * Must be called within a Test#describe method\n   *\n   * @returns {void}\n   */\n  test = ((\n    description:string,\n    action:TTestAction,\n    meta:TRunResultActionMeta|number\n  ) => {\n\n    let retry:number = this.testRetry || 0\n    let timeout:number = this.testTimeout\n\n    if(isObj(meta) && !exists(action.metaData) && !exists(action.ParkinMetaData)){\n      action.metaData = meta\n      if(meta?.timeout) timeout = meta.timeout\n      if(meta?.retry) retry = meta.retry\n    }\n    else if(isNum(meta)) timeout = meta\n\n    if (!this.#activeParent || this.#activeParent.type === Types.root)\n      throwError(`All ${Types.test} method calls must be called within a ${Types.describe} method`)\n\n    const item = createItem<TTestTestObj>(\n      Types.test,\n      {\n        retry,\n        action,\n        timeout,\n        description\n      }\n    )\n\n    item.disabled = () => (item.skip = true)\n\n    this.#activeParent.tests.push(item)\n  }) as TParkinTestFactory\n\n  /**\n   * Called when a test method should be skipped\n   * Must be called within a Test#describe method\n   *\n   * @returns {void}\n   */\n  xtest = (\n    description:string,\n    action?:TTestAction,\n    timeout?:number\n  ) => {\n    if (!this.#activeParent || this.#activeParent.type === Types.root)\n      throwError(\n        `All ${Types.test} method calls must be called within a ${Types.describe} method`\n      )\n\n    !isStr(description) &&\n      throwError(\n        `The ${Types.test} method requires a \"string\" as the first argument`\n      )\n    const item = createItem<TTestTestObj>(Types.test, { description, skip: true }, false)\n    item.disabled = () => (item.skip = true)\n\n    this.#activeParent.tests.push(item)\n  }\n\n}\n"],"mappings":"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","names":["OPTIONS","SHOULD_LOG","SHOULD_THROW","LOG_PREFIX","defaultValidator","validate","argObj","validators","options","logs","throws","prefix","validationCaseEntries","Object","entries","validationResults","map","argName","argValue","validateArgument","$default","reduceCases","total","next","validationReducer","success","cases","reduce","setOptions","undefined","resetOptions","key","value","validator","shouldStringifyValidator","name","validatorString","toString","reason","finalResult","nextValidation","handleFailure","validation","shouldLog","shouldThrow","Error","join","console","error","isArr","value","Array","isArray","isObj","obj","Array","isArray","isFunc","func","isStr","str","equalsNaN","val","isNum","typeOf","val","Object","prototype","toString","call","slice","isEmpty","isObj","keys","length","isArr","isStr","trim","isNum","isSame","val1","val2","isValidDate","date","isNaN","Date","getTime","isBool","val","toStr","val","undefined","isStr","JSON","stringify","isStrBool","val","convertToStrBool","isBool","toStr","toBool","isColl","val","isEmptyColl","obj","isArr","length","isColl","Object","getOwnPropertyNames","isArray","Array","keyList","keys","hasProp","prototype","hasOwnProperty","deepEqual","a","b","arrA","arrB","i","key","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","call","exists","value","undefined","isNegative","x","isNum","isPositive","isFloat","val","isInt","hasOwn","obj","prop","Object","prototype","hasOwnProperty","call","isEntry","maybeEntry","isArr","length","isNum","isStr","isArrMap","isObj","values","toBool","every","jsonEqual","one","two","JSON","stringify","e","isLowerCase","str","toLowerCase","isUpperCase","toUpperCase","isEmail","isStr","regex","Boolean","test","ipv4","ipv6","isIp","isIp4","isPhone","str","isStr","regex","Boolean","test","replace","length","isUrl","isUuid","quoteSymbols","isQuoted","quotes","some","quote","startsWith","endsWith","isValidUrl","str","regexp","test","isOrderable","x","isStr","isNum","isBool","identity","match","matchArg","args","length","entry","isArr","console","error","typeOf","caseValueOrPredicate","valueOnMatch","isFunc","default","hasDomAccess","window","document","createElement","isRegex","val","Boolean","RegExp","not","func","apply","bool","strBool","isStrBool","coll","isColl","deepEqual","emptyColl","isEmptyColl","dom","isDom","exists","empty","isEmpty","same","isSame","validDate","isValidDate","orderable","equalsNaN","float","isFloat","int","isInt","num","negative","isNegative","positive","isPositive","hasOwn","isEntry","arrMap","isArrMap","obj","isObj","jsonEqual","regex","email","isEmail","ip","isIp","lowerCase","isLowerCase","phone","isPhone","quoted","isQuoted","str","upperCase","isUpperCase","url","isUrl","uuid","isUuid","validUrl","isValidUrl","deepFreeze","obj","Object","freeze","getOwnPropertyNames","map","prop","hasOwnProperty","isFunc","isFrozen","noOpObj","noPropObj","deepFreeze","content","noPropArr","checkCall","method","params","isFunc","undefined","noOp","keyMap","arr","toUpperCase","isArr","reduce","obj","key","isStr","use","defObjProps","Array","from","concat","Object","getOwnPropertyNames","prototype","reduce","map","functionName","wait","time","Promise","res","setTimeout","EHookType","EStepType","validate"]}