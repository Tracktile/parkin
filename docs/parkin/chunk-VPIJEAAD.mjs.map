{"version":3,"sources":["../src/types/parkin.types.ts","../src/types/helpers.types.ts","../src/types/test.types.ts","../src/types/steps.types.ts","../src/types/assemble.types.ts","../src/constants.ts","../src/utils/errors.ts"],"sourcesContent":["import type { TWorldConfig } from './world.types'\nimport type { TFeatureAst } from './features.types'\nimport type {\n  TStepDef,\n  TStepDefs,\n  IParkinSteps,\n  EExpParmType,\n  TRegisterStepMethod,\n  TRegisterStepsList,\n  TStepTable,\n  TStepAst\n} from './steps.types'\n\nimport type { parseFeature } from '../parse/parseFeature'\nimport type {\n  TParamTypes,\n  TParamTypeMap,\n  TParamTypeModel,\n} from './paramTypes.types'\nimport { TAssemble } from './assemble.types'\n\nexport type TParkinHookName = `beforeAll`|`afterAll`|`beforeEach`|`afterEach`\nexport type TParkinHookCB = (...args:any[]) => any\nexport type TParkinHookMethod = (method:TParkinHookCB) => void\n\nexport interface IParkinHooks {\n  instance:IParkin\n  types:TParkinHookName[]\n  afterAll:TParkinHookMethod\n  beforeAll:TParkinHookMethod\n  afterEach:TParkinHookMethod\n  beforeEach:TParkinHookMethod\n  getRegistered:(type:TParkinHookName) => () => void\n}\n\nexport interface IParkinRunner {\n  run:TParkinRun\n  getFeatures:(\n    data:string|string[]|TFeatureAst|TFeatureAst[],\n    options:TParkinRunOpts\n  ) => TFeatureAst[]\n}\n\nexport type TParse = {\n  feature: typeof parseFeature\n  definition: (def:string) => TStepDef\n}\n\nexport type TMatchRespExt = {\n  world:TWorldConfig\n  doc?: any\n  step:TStepAst\n  table?: TStepTable\n  options?:Record<string, any>\n  [key:string]: any\n}\n\nexport type TNoExtMatchResp = {\n  match?: [...any]\n  definition?:TStepDef\n}\n\nexport type TMatchResp = {\n  match?: [...any, TMatchRespExt]\n  definition?:TStepDef\n}\n\nexport enum EPartMatchTypes {\n  other = `other`,\n  optional = `optional`,\n  alternate = `alternate`,\n  parameter = `parameter`,\n}\n\nexport type TPartsMatch = {\n  index:number\n  input:string\n  text: string\n  regex: RegExp\n  type: EPartMatchTypes\n  paramType: EExpParmType\n}\n\nexport type TExpFindResp = {\n  escaped:string\n  regexAlts:string\n  regexAnchors:string\n  regexConverted:string\n  found:TMatchResp,\n  transformers:TParamTypeModel[]\n}\n\nexport type TMatchTokens = {\n  type:string\n  match:string\n  index:number\n  defIndex:number\n}\n\nexport interface IMatcher {\n  types: () => TParamTypeMap\n  parts:(match:string) => TPartsMatch[]\n  register:(paramType:TParamTypeModel) => Record<string, TParamTypeModel>\n  stepTokens:(step:string, definition:TStepDef) => TMatchTokens[]\n  find: (definitions:TStepDefs, step:string, world:TWorldConfig) => TMatchResp\n  regex: (definition:TStepDef, step:string, world:TWorldConfig) => TMatchResp\n  expression: (definition:TStepDef, step:string, world:TWorldConfig) => TMatchResp\n  extract: (text:string, match:string, matchIdx:string[]) => Record<string|number, any>[]\n  expressionFind: (definition:TStepDef, step:string) => TExpFindResp\n}\n\ntype TParkinRunStepOpts = {\n  retry?:number\n  timeout?:number\n  disabled?: boolean\n  [K:string]:any\n}\n\nexport type TParkinRunStepOptsMap = {\n  shared:TParkinRunStepOpts\n  [K:string]:TParkinRunStepOpts\n}\n\nexport type TParkinRunTags = {\n  filter?: string|string[]\n  disabled?: string|string[]\n}\n\nexport type TParkinRunOpts = {\n  name?:string\n  retry?:number\n  timeout?:number\n  tags?: TParkinRunTags\n  steps?:TParkinRunStepOptsMap\n}\n\nexport type TParkinRun = (\n  data:string|string[]|TFeatureAst|TFeatureAst[],\n  options:TParkinRunOpts\n) => any\n\nexport type TRegisterStepsMethod = (\n  steps: TRegisterStepsList\n) => void\n\nexport interface IParkin {\n  parse:TParse\n  run:TParkinRun\n  matcher:IMatcher\n  world:TWorldConfig\n  assemble:TAssemble\n  steps:IParkinSteps\n  hooks:IParkinHooks\n  runner:IParkinRunner\n  Given:TRegisterStepMethod\n  When:TRegisterStepMethod\n  Then:TRegisterStepMethod\n  And:TRegisterStepMethod\n  But:TRegisterStepMethod\n  paramTypes:TParamTypes\n  registerSteps:TRegisterStepsMethod\n}\n\nexport type TParkinRunFeaturesInput = string|string[]|TFeatureAst[]|TFeatureAst","export enum EHookType {\n  beforeAll=`beforeAll`,\n  afterAll=`afterAll`,\n  beforeEach=`beforeEach`,\n  afterEach=`afterEach`\n}\n\nexport enum EStepType {\n  step=`step`,\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  \"*\"=`*`,\n}\n\nexport enum EStepMethodType {\n  Given=`Given`,\n  When=`When`,\n  Then=`Then`,\n  And=`And`,\n  But=`But`,\n  \"*\"=`*`,\n}\n\nexport enum EAstObject {\n  error=`error`,\n  tags=`tags`,\n  rule=`rule`,\n  rules=`rules`,\n  step=`step`,\n  steps=`steps`,\n  block=`block`,\n  blocks=`blocks`,\n  empty=`empty`,\n  reason=`reason`,\n  desire=`desire`,\n  comment=`comment`,\n  comments=`comments`,\n  feature=`feature`,\n  scenario=`scenario`,\n  scenarios=`scenarios`,\n  background=`background`,\n  perspective=`perspective`,\n\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  \"*\"=`*`,\n  \n  expression=`expression`,\n  expressions=`expressions`,\n}\n\nexport enum EFeatureTypes {\n  feature = `Feature`,\n  Feature = `Feature`,\n  FEATURE = `Feature`,\n  rule = `Rule`,\n  Rule = `Rule`,\n  background = `Background`,\n  Background = `Background`,\n  BACKGROUND = `Background`,\n  scenario = `Scenario`,\n  Scenario = `Scenario`,\n  SCENARIO = `Scenario`,\n  example = `Example`,\n  Example = `Example`,\n  EXAMPLE = `Example`,\n  step = `Step`,\n  Step = `Step`,\n  RULE = `Rule`,\n  STEP = `Step`\n}\n\nexport type TAnyFunc = (...args:any[]) => any\n","import type { Types } from '../test/utils'\nimport { TPromiseRetryCB } from './promise.types'\nimport type { ParkinError } from '../utils/errors'\nimport type { EAstObject, EStepType } from './helpers.types'\n\nexport enum EResultAction {\n  test=`test`,\n  skipped=`skipped`,\n  start=`start`,\n  end=`end`,\n  abort=`abort`\n}\n\nexport enum EResultStatus {\n  skipped=`skipped`,\n  passed=`passed`,\n  failed=`failed`,\n  warning=`warning`,\n}\n\nexport enum EResultType {\n  it=`it`,\n  xit=`xit`,\n  root=`root`,\n  test=`test`,\n  xtest=`xtest`,\n  describe=`describe`,\n  xdescribe=`xdescribe`\n}\n\nexport enum ETestType {\n  it = `it`,\n  itx = `itx`,\n  test = `test`,\n  testx = `testx`,\n  describe = `describe`,\n  describex = `describex`,\n  beforeAll = `beforeAll`,\n  afterAll = `afterAll`,\n  beforeEach = `beforeEach`,\n  afterEach = `afterEach`,\n}\n\nexport type TParkinResultMeta = {\n  uuid:string\n  index:number\n  type:EStepType\n}\n\nexport type TRunResultStepMeta = TParkinResultMeta & {\n  step:string\n  definition?:string\n  warnOnFailed?:boolean\n}\n\nexport type TRunResultScenarioMeta = TParkinResultMeta & {\n  tags?:string[]\n  scenario:string\n  warnOnFailed?:never\n}\n\nexport type TRunResultBackgroundMeta = TParkinResultMeta & {\n  tags?:string[]\n  background:string\n  warnOnFailed?:never\n}\n\nexport type TRunResultRuleMeta = TParkinResultMeta & {\n  tags?:string[]\n  rule:string\n  warnOnFailed?:never\n}\n\nexport type TRunResultFeatureMeta = TParkinResultMeta & {\n  tags?:string[]\n  feature:string\n  errors?:string[]\n  warnOnFailed?:never\n}\n\nexport type TRunMeta = {\n  warnOnFailed?:boolean\n  [K:string]: any\n}\nexport type TRunGeneralMeta<T extends Record<string, any>> = T\n\nexport type TRunResultActionMeta<T extends Record<string, any>=any> = TRunResultFeatureMeta\n  | TRunResultRuleMeta\n  | TRunResultBackgroundMeta\n  | TRunResultScenarioMeta\n  | TRunResultStepMeta\n  | TRunGeneralMeta<T>\n  | TRunMeta\n\nexport type TFailedErrorResult = Partial<TRunResult> & {\n  error: Error|ParkinError\n}\n\nexport type TRunResultTestMeta = Omit<Partial<TRunResult>, `passed`|`failed`> & {\n  failed?:TFailedErrorResult\n  passed?:Partial<TRunResult>|boolean\n}\n\nexport type TRunResult = {\n  id:string\n  testPath:string\n  fullName:string\n  failed?:boolean\n  passed?:boolean\n  skipped?:boolean\n  timestamp:number\n  children?:TSpec[]\n  stats: TTestStats\n  tests?:TRunResult[]\n  description: string\n  action:EResultAction\n  status?:EResultStatus\n  describes?:TRunResult[]\n  metaData?:TRunResultActionMeta\n  type:keyof typeof Types | EAstObject,\n  failedExpectations?:Partial<TRunResult>[]\n  passedExpectations?:Partial<TRunResult>[]\n}\n\nexport type TSpecResult = TRunResult & {\n  status?:EResultStatus\n}\n\nexport type TSpec = {\n  result: TSpecResult\n  disable: () => void\n}\n\nexport type TSuite = {\n  description: string\n  children: TSpec[]\n}\n\nexport type TParkinTestAbort = () => Promise<any>|any\nexport type TParkinTestCB = (result:TRunResult) => Promise<any>|any\n\nexport type TDescribeAction = (() => void) & {\n  metaData?:TRunResultActionMeta\n  ParkinMetaData?:TRunResultActionMeta\n}\n\nexport type TTestAction = ((done?:()=> void) => any) & {\n  metaData?:TRunResultActionMeta\n  ParkinMetaData?:TRunResultActionMeta\n}\n\nexport type TTestHookMethod = ((fn:(...args:any[]) => any, ...args:any[]) => any) & {\n  metaData?:TRunResultActionMeta\n  ParkinMetaData?:TRunResultActionMeta\n}\n\ntype TDescribeFactory = (description:string, action:TDescribeAction) => void\nexport type TParkinDescribeFactory = TDescribeFactory & {\n  skip:TDescribeFactory\n  only:TDescribeFactory\n}\n\ntype TTestFactory = (description:string, action:TTestAction, timeout?:number) => void\nexport type TParkinTestFactory = TTestFactory & {\n  skip:TTestFactory\n  only:TTestFactory\n}\n\n\nexport type TParkinTestConfig = {\n  bail?:number\n  timeout?:number\n  testRetry?:number\n  suiteRetry?:number\n  autoClean?:boolean\n  description?:string\n  testTimeout?:number\n  suiteTimeout?:number\n  exitOnFailed?:boolean\n  skipAfterFailed?:boolean\n  onAbort?:TParkinTestAbort\n  onRunDone?:TParkinTestCB\n  onSpecDone?:TParkinTestCB\n  onRunStart?:TParkinTestCB\n  onSuiteDone?:TParkinTestCB\n  onSpecStart?:TParkinTestCB\n  onSuiteStart?:TParkinTestCB\n  onTestRetry?:TPromiseRetryCB<TRunResult>\n  onSuiteRetry?:TPromiseRetryCB<TRunResults>\n}\n\n// TODO: fix these types\nexport type TBaseTestObj = {\n  only?:boolean\n  skip?: boolean\n  timeout?:number\n  description:string\n  onlyChild?: boolean\n  disabled: () => void\n  hasOnlyChild: () => void\n  // type:keyof typeof Types,\n}\n\nexport type TTestTestObj = TBaseTestObj & {\n  retry?:number\n  action:TTestAction\n  type: `test` | `it` | `xtest` | `xit`\n}\n\nexport type THookTestObj = {\n  type: `beforeAll` | `beforeEach` | `afterAll` | `afterEach`\n  description?:string\n  action:TTestHookMethod\n}\n\nexport type TDescribeTestObj = TBaseTestObj & {\n  type: `describe`\n  childError?:Error\n  tests?:TTestTestObj[]\n  action:TDescribeAction\n  describes?:TDescribeTestObj[]\n  afterAll?:TTestHookMethod[]\n  beforeAll?:TTestHookMethod[]\n  afterEach?:TTestHookMethod[]\n  beforeEach?:TTestHookMethod[]\n}\n\nexport type TRootTestObj = TBaseTestObj & {\n  type: `root`\n  childError?:Error\n  tests?:TTestTestObj[]\n  action:TDescribeAction\n  describes?:TDescribeTestObj[]\n  afterAll?:TTestHookMethod[]\n  beforeAll?:TTestHookMethod[]\n  afterEach?:TTestHookMethod[]\n  beforeEach?:TTestHookMethod[]\n}\n\nexport type TParentTestObj = TRootTestObj | TDescribeTestObj\n\nexport type TNonRootTestObj = TDescribeTestObj | TTestTestObj\n\nexport type TTestObj = TRootTestObj\n  | TNonRootTestObj\n  | THookTestObj\n\n\n\nexport type THookTypes = {\n  beforeAll:`beforeAll`\n  beforeEach:`beforeEach`\n  afterAll:`afterAll`\n  afterEach:`afterEach`\n}\n\nexport type TGlobalTypes = THookTypes & {\n  test:`test`\n  it:`it`\n  xtest:`xtest`\n  xit:`xit`\n  describe:`describe`\n}\n\nexport type TType = TGlobalTypes & {\n  root: `root`\n}\n\n\nexport type TRunResults = (TRunResult[] & TTestStats & {\n  aborted?:boolean\n  bailed?:boolean\n})\n\nexport type TTestStats = {\n  runEnd?:number\n  runStart?:number\n  passedSpecs?:number\n  failedSpecs?:number\n  failedSuites?:number\n  passedSuites?:number\n}\n\nexport type TLoopTests = {\n  bail:number\n  suiteId:string\n  testOnly:boolean\n  testRetry?:number\n  exitOnFailed?:boolean\n  skipAfterFailed?:boolean\n  stats: TTestStats\n  onSpecDone:TParkinTestCB\n  shouldAbort:() => boolean\n  onSpecStart:TParkinTestCB\n  describe:TDescribeTestObj\n  onTestRetry?:TPromiseRetryCB<TRunResult>\n}\n\nexport type TRun = {\n  bail?:number\n  stats: TTestStats\n  testOnly:boolean\n  testRetry?:number\n  describeOnly:boolean\n  exitOnFailed?:boolean\n  skipAfterFailed?:boolean\n  onSpecDone:TParkinTestCB\n  onRunDone:TParkinTestCB\n  onSuiteDone:TParkinTestCB\n  onAbort:TParkinTestAbort\n  parentIdx?:string|number\n  shouldAbort:() => boolean\n  onSpecStart:TParkinTestCB\n  onRunStart:TParkinTestCB\n  onSuiteStart:TParkinTestCB\n  root:TRootTestObj|TDescribeTestObj\n  onTestRetry?:TPromiseRetryCB<TRunResult>\n}\n","import type { TWorldConfig } from './world.types'\nimport type { EStepType } from './helpers.types'\nimport type { TMatchResp } from './parkin.types'\nimport {TTagsAst} from './features.types'\n\nexport type TStepAction = (...args:any[]) => any\nexport type TRegisterStepMethod = (step:string, action:TStepAction) => any\nexport type TRegisterStepMap = Record<string, TRegisterStepMethod>\nexport type TRegisterStepsList = Record<`given`|`when`|`then`|`and`|`but`, TRegisterStepMap>\n\nexport type TStepDefsList = Record<string, TStepDef>\nexport type TAddStepDefs = TStepDef|TStepDef[]|TStepDefsList\nexport type TRegisterOrAddStep = TAddStepDefs|TRegisterStepsList\n\nexport interface IParkinSteps {\n  world:TWorldConfig\n  clear: () => void\n  list:() => TStepDefs\n  But:TRegisterStepMethod\n  And:TRegisterStepMethod\n  When:TRegisterStepMethod\n  Then:TRegisterStepMethod\n  Given:TRegisterStepMethod\n  typeList: () => TStepDefs\n  resolve:(match:string) => any\n  match: (match:string) => TMatchResp\n  register:(def:string|TStepDef[]|TStepDef, match:string, TStepAction) => void\n}\n\nexport type TStepAst = {\n  doc?: any\n  uuid: string\n  step: string\n  index: number\n  type: EStepType\n  tags?: TTagsAst\n  disabled?:boolean\n  whitespace: string\n  definition?:string\n  table?: TStepTable\n}\n\nexport enum EStepVariant {\n  regex = 'regex',\n  expression = 'expression'\n}\n\nexport type TStepToken = {\n  [key:string]: any\n}\n\nexport enum EStepKey {\n  given=`given`,\n  when=`when`,\n  then=`then`,\n  and=`and`,\n  but=`but`,\n  Given=`given`,\n  When=`when`,\n  Then=`then`,\n  And=`and`,\n  But=`but`,\n} \n\nexport enum EExpParmKind {\n  url = `url`,\n  text = `text`,\n  alias = `alias`,\n  pairs = `pairs`,\n  group = `group`,\n  number = `number`,\n  element = `element`,\n  selector = `selector`,\n}\n\nexport enum EExpParmType {\n  any = `any`,\n  int = `int`,\n  word = `word`,\n  array = `array`,\n  float = `float`,\n  string = `string`,\n  number = `number`,\n  object = `object`,\n}\n\nexport type TStepMetaExpression = {\n  kind?: EExpParmKind\n  type: EExpParmType\n  example: string,\n  description: string,\n}\n\n\nexport type TStepMeta = {\n  // TO Be Removed once all steps are updated\n  race?: boolean\n  // TO Be Removed once all steps are updated\n\n  module?:string\n  name?:string\n  info?:string\n  alias?: string[]\n  examples?: string[]\n  description?:string\n  expressions?:TStepMetaExpression[]\n}\n\nexport type TStepParent = {\n  uuid: string\n  location: string\n}\n\nexport type TStepDefMethod = (...args:any) => any\nexport type TStepDef = {\n  type: string\n  name: string\n  uuid: string\n  variant:string\n  content: string\n  meta: TStepMeta\n  location?: string,\n  definition?:string\n  match: string | RegExp\n  parent?: TStepParent\n  tokens: TStepToken[]\n  method: TStepDefMethod\n}\nexport type TStepDefsArr = TStepDef[]\n\nexport type TStepDefs = {\n  [key in keyof EStepType]: TStepDefsArr\n}\n\nexport type TStepTable = {\n  index: number\n  content: string[][]\n}\n\nexport type TStepDoc = {\n  index:number\n  whiteSpace:string\n  type:`quote`|`tick`\n  content: string[]\n}\n\nexport type TStepResolveOpts = {\n  [K:string]:any\n}","import type { assemble } from '../assemble'\nimport type { EAstObject, EStepType } from './helpers.types'\nimport type { TParentAst, TFeatureAst, } from './features.types'\nimport {TStepAst} from './steps.types'\n\nexport type TAssemble = typeof assemble\n\nexport enum EBlockLoc {\n  after=`after`,\n  before=`before`,\n}\n\nexport type TFindIndex = {\n  type:EAstObject|EStepType\n  feature:TFeatureAst\n  loc?:EBlockLoc|string\n  parent:TParentAst|TStepAst\n}\n\nexport type TAssembleOpts = {\n  removeEmpty?: boolean\n  removeComments?: boolean\n  emptyAfterRule?: boolean\n  emptyAfterSteps?:boolean\n  emptyAfterStory?: boolean\n  emptyAfterFeature?: boolean\n  emptyAfterScenario?: boolean\n  emptyAfterBackground?: boolean\n  backgroundAfterParent?: boolean\n}","import { EAstObject, EStepType, EHookType } from './types'\nimport { deepFreeze } from '@keg-hub/jsutils'\n\nconst ignoreTypes = [\n  `*`,\n  ``,\n]\n\nexport const constants = deepFreeze({\n  ALIAS_REF: `$$`,\n  ALIAS_WORLD_KEY: `$alias`,\n  ALIAS_REF_AT_RUNTIME: `$$:`,\n  REGEX_VARIANT: 'regex',\n  WORLD_REF: `$`,\n  WORLD_KEY: `$world`,\n  WORLD_AT_RUNTIME: `$:`,\n  EXPRESSION_VARIANT: 'expression',\n  HOOK_TYPES: Object.keys(EHookType),\n  STEP_TYPES: Object.keys(EStepType).filter(type => !ignoreTypes.includes(type)),\n  FEATURE_META: [ 'feature', 'perspective', 'desire', 'reason', 'comments' ],\n  LOG_JEST_SPEC_ENV: `PARKIN_LOG_JEST_SPEC`,\n  SPEC_RESULT_LOG: `------- PARKIN SPEC RESULT LOG -------`,\n})\n\nexport const ParentTypes = [\n  EAstObject.rule,\n  EAstObject.scenario,\n  EAstObject.background,\n]\n\nexport const StepTypes = [\n  EAstObject.given,\n  EAstObject.when,\n  EAstObject.then,\n  EAstObject.and,\n  EAstObject.but,\n  EAstObject[`*`],\n  EAstObject.step,\n  EAstObject.steps,\n]\n\nexport const ParkinBailErrName = `ParkinBailError`\nexport const ParkinAbortErrName = `ParkinAbortError`","import {isStr} from '@keg-hub/jsutils'\nimport { ParkinAbortErrName, ParkinBailErrName } from '../constants'\nimport { EHookType, TRunResults } from '../types'\n\nconst resolveErrMsg = (error?:string|Error, maybe?:Error|string):[string, Error] => {\n  return isStr(error)\n    ? [error as string, maybe as Error]\n    : [((error || maybe) as Error)?.message, (error || maybe) as Error]\n}\n\nconst replaceStackMsg = (err:Error, msg:string) => {\n  const split = err.stack.split(`\\n`)\n  split[0] = msg\n\n  return split.join(`\\n`)\n}\n\nexport class ParkinError extends Error {\n  name = `ParkinError`\n  results?:TRunResults\n  testResults?:TRunResults\n\n  constructor(msg:string|Error, error?:string|Error|ParkinError, replaceStack:boolean=true){\n    const [message, err] = resolveErrMsg(msg, error)\n    const { stackTraceLimit } = Error\n    if(err && replaceStack){\n      // Create a new error without a stacktrace\n      Error.stackTraceLimit = 0\n    }\n\n    // Set the error cause if it's different form the message\n    const opts = err && message !== err?.message\n      ? { cause: err?.message }\n      : undefined\n\n    super(message, opts)\n\n    this.results = (err as ParkinError)?.results || []\n    this.testResults = (err as ParkinError)?.testResults || []\n\n    if((err as any)?.result && !this.results.includes((err as any).result))\n      this.results.push((err as any).result)\n\n    // Reset the original stacktrace limit\n    Error.stackTraceLimit = stackTraceLimit\n    this.name = this.constructor.name\n    \n    if(replaceStack){\n      if(err?.stack) this.stack = replaceStackMsg(err, message)\n      err && Error.captureStackTrace(err, this.constructor)\n    }\n  }\n}\n\nexport class ParkinBailError extends ParkinError {\n  name = ParkinBailErrName\n  constructor(msg:string|Error, error?:string|Error, replaceStack:boolean=true){\n    super(msg, error, replaceStack)\n  }\n}\n\nexport class ParkinAbortError extends ParkinError {\n  name = ParkinAbortErrName\n  constructor(msg:string|Error, error?:string|Error, replaceStack:boolean=true){\n    super(msg, error, replaceStack)\n  }\n}\n\nexport class RetryError extends Error {\n  results?:TRunResults\n  constructor(err:Error, message?:string, retry?:number) {\n    super(message || err.message)\n    this.stack = err.stack\n    // Only overwrite the default Error name when retry was actually set\n    // Keep custom named errors incase they are depended on\n    this.name = !retry ? err.name : this.constructor.name\n\n    if(message) this.cause = err.message\n    if((err as RetryError).results) this.results = (err as RetryError).results\n  }\n}\n\n/*\n * Helper method to use throw a Parkin Bail error\n * @function\n * @public\n * @throws\n *\n */\nexport const throwAbortError = (err?:Error) => {\n  throw new ParkinAbortError(\n    `Test execution \\x1b[33m\"aborted\"\\x1b[0m`,\n    err,\n    true\n  )\n}\n\n/*\n * Helper method to use throw a Parkin Bail error\n * @function\n * @public\n * @throws\n *\n */\nexport const throwBailError = (err:Error, bail?:number) => {\n  const colored = `\\x1b[33m${bail}\\x1b[0m`\n  throw new ParkinBailError(\n    `Stopping test execution. Max allowed failed${bail ? ` ${colored} ` : ` `}tests has been reached`,\n    err,\n    true\n  )\n}\n\nexport const throwExitOnFailed = (err:Error) => {\n  throw new ParkinBailError(\n    `Stopping test execution. A test failed and \\x1b[33m\"exitOnFailed\"\\x1b[0m is active`,\n    err,\n    true\n  )\n}\n\n/*\n * Helper method to use the a test method can not be found on the global scope\n * @function\n * @public\n * @throws\n *\n */\nexport const testMethodFill = (type:string) => {\n  /*\n   * Internal method that throws an error when a test method does not exist on the global scope\n   * @function\n   * @private\n   * @inner\n   *\n   */\n  return () => {\n    throw new ParkinError(\n      `` +\n        `Test method ${type} does not exist on the global scope.\\n` +\n        `Please ensure ${type} exists before calling the run method!\\n`\n    )\n  }\n}\n\n/**\n * Throws an error when a Steps class instance is not passed to the runner class constructor\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingSteps = () => {\n  throw new ParkinError(\n    `Runner class constructor requires an instance of the Steps class`\n  )\n}\n\n/**\n * Throws an error when a Hooks class instance is not passed to the runner class constructor\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingHooks = (found:any) => {\n  throw new ParkinError(\n    `Runner class constructor requires an instance of the Hooks class. Found: ${found}`\n  )\n}\n\n/**\n * Throws an error when a feature text is not passed to the Runner class instance\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingFeatureText = () => {\n  throw new ParkinError(\n    `Runner class requires feature text when calling the run method`\n  )\n}\n\n/**\n * Throws an error when a feature step does not match a step definition\n * @function\n * @public\n * @throws\n *\n */\nexport const throwNoMatchingStep = (text:string) => {\n  throw new ParkinError(text)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @throws\n *\n */\nexport const throwParamTypeExists = (name:string) => {\n  throw new ParkinError(`Cannot register param type \"${name}\". It already exists!`)\n}\n\n/**\n * Throws an error when a assembling a parsed feature, and no parsed feature object exists\n * @function\n * @public\n * @throws\n * \n */\nexport const throwFeatureNotAnObj = (feature:any) => {\n  throw new ParkinError(`Assemble feature requires an object matching the feature model spec!`)\n}\n\n/**\n * Throws an error when a registering a param type that already exists\n * @function\n * @public\n * @throws\n *\n */\nexport const throwMissingWorldValue = (arg:string) => {\n  throw new ParkinError(\n    `Can not replace ${arg} with value from $world, it does not exist on the world object`,\n  )\n}\n\n/**\n * Throws an error when a registering an invalid hook type\n * @function\n * @public\n * @throws\n *\n */\nexport const throwInvalidHookType = (hookTypes:EHookType, type:string) => {\n  throw new ParkinError(\n    [\n      `Expected client hook type to be one of ', ${hookTypes}.`,\n      `Found: ${type}`,\n    ].join('\\n')\n  )\n}\n\n/**\n * Throws an error when running world replace on feature text content\n * @function\n * @public\n * @throws\n *\n */\nexport const throwWorldReplace = (err:Error, currentMatch:string) => {\n  throw new ParkinError(`Error replacing $world value in feature text. Current match was ${currentMatch}`, err)\n}\n\n/**\n * Throws an error when running world.alias replace on feature text content\n * @function\n * @public\n * @throws\n *\n */\nexport const throwAliasReplace = (err:Error, currentMatch:string) => {\n  throw new ParkinError(\n    `Error replacing $$alias ( $world.$alias ) in feature text. Current match was ${currentMatch}`,\n    err\n  )\n}\n"],"mappings":";;;;;;AAmEO,IAAK,kBAAL,kBAAKA,qBAAL;AACL,EAAAA,iBAAA,WAAQ;AACR,EAAAA,iBAAA,cAAW;AACX,EAAAA,iBAAA,eAAY;AACZ,EAAAA,iBAAA,eAAY;AAJF,SAAAA;AAAA,GAAA;;;ACnEL,IAAK,YAAL,kBAAKC,eAAL;AACL,EAAAA,WAAA,eAAU;AACV,EAAAA,WAAA,cAAS;AACT,EAAAA,WAAA,gBAAW;AACX,EAAAA,WAAA,eAAU;AAJA,SAAAA;AAAA,GAAA;AAOL,IAAK,YAAL,kBAAKC,eAAL;AACL,EAAAA,WAAA,UAAK;AACL,EAAAA,WAAA,WAAM;AACN,EAAAA,WAAA,UAAK;AACL,EAAAA,WAAA,UAAK;AACL,EAAAA,WAAA,SAAI;AACJ,EAAAA,WAAA,SAAI;AACJ,EAAAA,WAAA,OAAI;AAPM,SAAAA;AAAA,GAAA;AAUL,IAAK,kBAAL,kBAAKC,qBAAL;AACL,EAAAA,iBAAA,WAAM;AACN,EAAAA,iBAAA,UAAK;AACL,EAAAA,iBAAA,UAAK;AACL,EAAAA,iBAAA,SAAI;AACJ,EAAAA,iBAAA,SAAI;AACJ,EAAAA,iBAAA,OAAI;AANM,SAAAA;AAAA,GAAA;AASL,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,YAAA,WAAM;AACN,EAAAA,YAAA,UAAK;AACL,EAAAA,YAAA,UAAK;AACL,EAAAA,YAAA,WAAM;AACN,EAAAA,YAAA,UAAK;AACL,EAAAA,YAAA,WAAM;AACN,EAAAA,YAAA,WAAM;AACN,EAAAA,YAAA,YAAO;AACP,EAAAA,YAAA,WAAM;AACN,EAAAA,YAAA,YAAO;AACP,EAAAA,YAAA,YAAO;AACP,EAAAA,YAAA,aAAQ;AACR,EAAAA,YAAA,cAAS;AACT,EAAAA,YAAA,aAAQ;AACR,EAAAA,YAAA,cAAS;AACT,EAAAA,YAAA,eAAU;AACV,EAAAA,YAAA,gBAAW;AACX,EAAAA,YAAA,iBAAY;AAEZ,EAAAA,YAAA,WAAM;AACN,EAAAA,YAAA,UAAK;AACL,EAAAA,YAAA,UAAK;AACL,EAAAA,YAAA,SAAI;AACJ,EAAAA,YAAA,SAAI;AACJ,EAAAA,YAAA,OAAI;AAEJ,EAAAA,YAAA,gBAAW;AACX,EAAAA,YAAA,iBAAY;AA5BF,SAAAA;AAAA,GAAA;AA+BL,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,UAAO;AACP,EAAAA,eAAA,UAAO;AACP,EAAAA,eAAA,gBAAa;AACb,EAAAA,eAAA,gBAAa;AACb,EAAAA,eAAA,gBAAa;AACb,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,UAAO;AACP,EAAAA,eAAA,UAAO;AACP,EAAAA,eAAA,UAAO;AACP,EAAAA,eAAA,UAAO;AAlBG,SAAAA;AAAA,GAAA;;;ACpDL,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,eAAA,UAAK;AACL,EAAAA,eAAA,aAAQ;AACR,EAAAA,eAAA,WAAM;AACN,EAAAA,eAAA,SAAI;AACJ,EAAAA,eAAA,WAAM;AALI,SAAAA;AAAA,GAAA;AAQL,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,eAAA,aAAQ;AACR,EAAAA,eAAA,YAAO;AACP,EAAAA,eAAA,YAAO;AACP,EAAAA,eAAA,aAAQ;AAJE,SAAAA;AAAA,GAAA;AAOL,IAAK,cAAL,kBAAKC,iBAAL;AACL,EAAAA,aAAA,QAAG;AACH,EAAAA,aAAA,SAAI;AACJ,EAAAA,aAAA,UAAK;AACL,EAAAA,aAAA,UAAK;AACL,EAAAA,aAAA,WAAM;AACN,EAAAA,aAAA,cAAS;AACT,EAAAA,aAAA,eAAU;AAPA,SAAAA;AAAA,GAAA;AAUL,IAAK,YAAL,kBAAKC,eAAL;AACL,EAAAA,WAAA,QAAK;AACL,EAAAA,WAAA,SAAM;AACN,EAAAA,WAAA,UAAO;AACP,EAAAA,WAAA,WAAQ;AACR,EAAAA,WAAA,cAAW;AACX,EAAAA,WAAA,eAAY;AACZ,EAAAA,WAAA,eAAY;AACZ,EAAAA,WAAA,cAAW;AACX,EAAAA,WAAA,gBAAa;AACb,EAAAA,WAAA,eAAY;AAVF,SAAAA;AAAA,GAAA;;;ACYL,IAAK,eAAL,kBAAKC,kBAAL;AACL,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,gBAAa;AAFH,SAAAA;AAAA,GAAA;AASL,IAAK,WAAL,kBAAKC,cAAL;AACL,EAAAA,UAAA,WAAM;AACN,EAAAA,UAAA,UAAK;AACL,EAAAA,UAAA,UAAK;AACL,EAAAA,UAAA,SAAI;AACJ,EAAAA,UAAA,SAAI;AACJ,EAAAA,UAAA,WAAM;AACN,EAAAA,UAAA,UAAK;AACL,EAAAA,UAAA,UAAK;AACL,EAAAA,UAAA,SAAI;AACJ,EAAAA,UAAA,SAAI;AAVM,SAAAA;AAAA,GAAA;AAaL,IAAK,eAAL,kBAAKC,kBAAL;AACL,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,aAAU;AACV,EAAAA,cAAA,cAAW;AARD,SAAAA;AAAA,GAAA;AAWL,IAAK,eAAL,kBAAKC,kBAAL;AACL,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,SAAM;AACN,EAAAA,cAAA,UAAO;AACP,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,WAAQ;AACR,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,YAAS;AARC,SAAAA;AAAA,GAAA;;;ACpEL,IAAK,YAAL,kBAAKC,eAAL;AACL,EAAAA,WAAA,WAAM;AACN,EAAAA,WAAA,YAAO;AAFG,SAAAA;AAAA,GAAA;;;ACJZ,IAAM,cAAc;AAAA,EAClB;AAAA,EACA;AACF;AAEO,IAAM,YAAY,WAAW;AAAA,EAClC,WAAW;AAAA,EACX,iBAAiB;AAAA,EACjB,sBAAsB;AAAA,EACtB,eAAe;AAAA,EACf,WAAW;AAAA,EACX,WAAW;AAAA,EACX,kBAAkB;AAAA,EAClB,oBAAoB;AAAA,EACpB,YAAY,OAAO,KAAK,SAAS;AAAA,EACjC,YAAY,OAAO,KAAK,SAAS,EAAE,OAAO,UAAQ,CAAC,YAAY,SAAS,IAAI,CAAC;AAAA,EAC7E,cAAc,CAAE,WAAW,eAAe,UAAU,UAAU,UAAW;AAAA,EACzE,mBAAmB;AAAA,EACnB,iBAAiB;AACnB,CAAC;AAEM,IAAM,cAAc;AAAA;AAAA;AAAA;AAI3B;AAEO,IAAM,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASzB;AAEO,IAAM,oBAAoB;AAC1B,IAAM,qBAAqB;;;ACtClC,IAAM,gBAAgB,CAAC,OAAqB,UAAwC;AAClF,SAAO,MAAM,KAAK,IACd,CAAC,OAAiB,KAAc,IAChC,EAAG,SAAS,QAAkB,SAAU,SAAS,KAAe;AACtE;AAEA,IAAM,kBAAkB,CAAC,KAAW,QAAe;AACjD,QAAM,QAAQ,IAAI,MAAM,MAAM;AAAA,CAAI;AAClC,QAAM,CAAC,IAAI;AAEX,SAAO,MAAM,KAAK;AAAA,CAAI;AACxB;AAEO,IAAM,cAAN,cAA0B,MAAM;AAAA,EACrC,OAAO;AAAA,EACP;AAAA,EACA;AAAA,EAEA,YAAY,KAAkB,OAAiC,eAAqB,MAAK;AACvF,UAAM,CAAC,SAAS,GAAG,IAAI,cAAc,KAAK,KAAK;AAC/C,UAAM,EAAE,gBAAgB,IAAI;AAC5B,QAAG,OAAO,cAAa;AAErB,YAAM,kBAAkB;AAAA,IAC1B;AAGA,UAAM,OAAO,OAAO,YAAY,KAAK,UACjC,EAAE,OAAO,KAAK,QAAQ,IACtB;AAEJ,UAAM,SAAS,IAAI;AAEnB,SAAK,UAAW,KAAqB,WAAW,CAAC;AACjD,SAAK,cAAe,KAAqB,eAAe,CAAC;AAEzD,QAAI,KAAa,UAAU,CAAC,KAAK,QAAQ,SAAU,IAAY,MAAM;AACnE,WAAK,QAAQ,KAAM,IAAY,MAAM;AAGvC,UAAM,kBAAkB;AACxB,SAAK,OAAO,KAAK,YAAY;AAE7B,QAAG,cAAa;AACd,UAAG,KAAK;AAAO,aAAK,QAAQ,gBAAgB,KAAK,OAAO;AACxD,aAAO,MAAM,kBAAkB,KAAK,KAAK,WAAW;AAAA,IACtD;AAAA,EACF;AACF;AAEO,IAAM,kBAAN,cAA8B,YAAY;AAAA,EAC/C,OAAO;AAAA,EACP,YAAY,KAAkB,OAAqB,eAAqB,MAAK;AAC3E,UAAM,KAAK,OAAO,YAAY;AAAA,EAChC;AACF;AAEO,IAAM,mBAAN,cAA+B,YAAY;AAAA,EAChD,OAAO;AAAA,EACP,YAAY,KAAkB,OAAqB,eAAqB,MAAK;AAC3E,UAAM,KAAK,OAAO,YAAY;AAAA,EAChC;AACF;AAEO,IAAM,aAAN,cAAyB,MAAM;AAAA,EACpC;AAAA,EACA,YAAY,KAAW,SAAiB,OAAe;AACrD,UAAM,WAAW,IAAI,OAAO;AAC5B,SAAK,QAAQ,IAAI;AAGjB,SAAK,OAAO,CAAC,QAAQ,IAAI,OAAO,KAAK,YAAY;AAEjD,QAAG;AAAS,WAAK,QAAQ,IAAI;AAC7B,QAAI,IAAmB;AAAS,WAAK,UAAW,IAAmB;AAAA,EACrE;AACF;AASO,IAAM,kBAAkB,CAAC,QAAe;AAC7C,QAAM,IAAI;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AASO,IAAM,iBAAiB,CAAC,KAAW,SAAiB;AACzD,QAAM,UAAU,WAAW,IAAI;AAC/B,QAAM,IAAI;AAAA,IACR,8CAA8C,OAAO,IAAI,OAAO,MAAM,GAAG;AAAA,IACzE;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,oBAAoB,CAAC,QAAc;AAC9C,QAAM,IAAI;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AASO,IAAM,iBAAiB,CAAC,SAAgB;AAQ7C,SAAO,MAAM;AACX,UAAM,IAAI;AAAA,MACR,eACiB,IAAI;AAAA,gBACF,IAAI;AAAA;AAAA,IACzB;AAAA,EACF;AACF;AASO,IAAM,oBAAoB,MAAM;AACrC,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AASO,IAAM,oBAAoB,CAAC,UAAc;AAC9C,QAAM,IAAI;AAAA,IACR,4EAA4E,KAAK;AAAA,EACnF;AACF;AASO,IAAM,0BAA0B,MAAM;AAC3C,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AASO,IAAM,sBAAsB,CAAC,SAAgB;AAClD,QAAM,IAAI,YAAY,IAAI;AAC5B;AASO,IAAM,uBAAuB,CAAC,SAAgB;AACnD,QAAM,IAAI,YAAY,+BAA+B,IAAI,uBAAuB;AAClF;AASO,IAAM,uBAAuB,CAAC,YAAgB;AACnD,QAAM,IAAI,YAAY,sEAAsE;AAC9F;AASO,IAAM,yBAAyB,CAAC,QAAe;AACpD,QAAM,IAAI;AAAA,IACR,mBAAmB,GAAG;AAAA,EACxB;AACF;AASO,IAAM,uBAAuB,CAAC,WAAqB,SAAgB;AACxE,QAAM,IAAI;AAAA,IACR;AAAA,MACE,6CAA6C,SAAS;AAAA,MACtD,UAAU,IAAI;AAAA,IAChB,EAAE,KAAK,IAAI;AAAA,EACb;AACF;AASO,IAAM,oBAAoB,CAAC,KAAW,iBAAwB;AACnE,QAAM,IAAI,YAAY,mEAAmE,YAAY,IAAI,GAAG;AAC9G;AASO,IAAM,oBAAoB,CAAC,KAAW,iBAAwB;AACnE,QAAM,IAAI;AAAA,IACR,gFAAgF,YAAY;AAAA,IAC5F;AAAA,EACF;AACF;","names":["EPartMatchTypes","EHookType","EStepType","EStepMethodType","EAstObject","EFeatureTypes","EResultAction","EResultStatus","EResultType","ETestType","EStepVariant","EStepKey","EExpParmKind","EExpParmType","EBlockLoc"]}