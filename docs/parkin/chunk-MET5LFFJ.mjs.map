{"version":3,"sources":["../src/test/utils.ts","../src/test/runResult.ts","../src/test/hooks.ts","../src/utils/promiseRetry.ts","../src/utils/promiseTimeout.ts","../src/test/runTest.ts","../src/test/runHelpers.ts","../src/test/loopTests.ts","../src/test/loopDescribes.ts","../src/test/run.ts","../src/test/test.ts"],"sourcesContent":["import type {\n  TType,\n  TTestObj,\n  THookTypes,\n  TTestAction,\n  TRootTestObj,\n  TGlobalTypes,\n  TTestHookMethod,\n  TDescribeAction,\n  TDescribeTestObj,\n} from '../types'\n\nimport { ParkinError } from '../utils/errors'\nimport { keyMap, isFunc, isStr, noOpObj } from '@keg-hub/jsutils'\n\n/**\n * @type {Object}\n * Key value pair of all helper method names for the ParkinTest Class\n */\nexport const hookTypes = keyMap<THookTypes>([\n  `beforeAll`,\n  `beforeEach`,\n  `afterAll`,\n  `afterEach`,\n])\n\n/**\n * @type {Object}\n * Key value pair of all methods added to the global scope\n */\nexport const globalTypes:TGlobalTypes = {\n  ...keyMap([ `test`, `it`, `xtest`, `xit`, `describe` ]),\n  ...hookTypes,\n}\n\n/**\n * @type {Object}\n * Key value pair of allowed Types for the ParkinTest Class\n */\nexport const Types:TType = {\n  ...globalTypes,\n  ...keyMap([`root`]),\n}\n\n/**\n * Adds the class instance methods to the global scope\n * @param {Object} instance - An instance of the ParkinTest Class\n *\n * @returns void\n */\nexport const addToGlobal = (instance:TTestObj) => {}\n\n/**\n * Throws an Error from the passed in error\n * @param {string} error - The Error message or Object to throw\n *\n * @throws\n */\nexport const throwError = (error:string) => {\n  throw new ParkinError(error)\n}\n\n/**\n * Validates the required arguments were passed in of a helper method\n * @throws\n *\n */\nexport const validateHook = (\n  type:keyof typeof Types,\n  action:TTestHookMethod,\n) => {\n  !isFunc(action) &&\n    throwError(\n      `The ${type} method requires a \"function\" as the first argument`\n    )\n}\n\nexport const validateRootRun = (root:TRootTestObj) => {\n  root.type !== Types.root &&\n    throwError(`Invalid root type \"${root.type}\" set for root object`)\n  !root.describes ||\n    (!root.describes.length &&\n      throwError(`No tests have been registered to this ParkinTest instance`))\n}\n\n/**\n * Validates the required arguments were passed in\n * @throws\n *\n */\nexport const validateItem = (\n  type:string,\n  description:string,\n  action:TTestAction|TDescribeAction\n) => {\n  !isStr(type) && throwError(`Test item type is required as a string`)\n  !isFunc(action) &&\n    throwError(\n      `The ${type} method requires a \"function\" as the second argument`\n    )\n  !isStr(description) &&\n    throwError(`The ${type} method requires a \"string\" as the first argument`)\n}\n\n/**\n * Creates an object with meta data of an item of the ParkinTest instance\n *\n */\nexport const createItem = <T=TTestObj>(\n  type:string,\n  metadata:Partial<TTestObj> = noOpObj as TTestObj,\n  validate = true\n) => {\n  const { description, action } = metadata\n  validate && validateItem(type, description, action)\n\n  return { ...metadata, type } as T\n}\n\n/**\n * Creates a describe object for the passed in description and action\n *\n */\nexport const createDescribe = (\n  description:string,\n  action:TDescribeAction\n) => {\n  const item = createItem(Types.describe, {\n    ...createRoot(),\n    action,\n    tests: [],\n    description,\n  }) as TDescribeTestObj\n\n  item.disabled = () => (item.skip = true)\n\n  return item\n}\n\n/**\n * Creates a root object\n *\n */\nexport const createRoot = () => {\n  return createItem(\n    Types.root,\n    {\n      describes: [],\n      ...Object.values(hookTypes).reduce((acc, type) => {\n        acc[type] = []\n        return acc\n      }, {}),\n    },\n    false\n  ) as TRootTestObj\n}\n","import type {\n  TTestObj,\n  TRunResult,\n  TRunResultTestMeta\n} from '../types'\nimport { EResultStatus } from '../types'\nimport { isObj } from '@keg-hub/jsutils'\n\n\n/**\n * Builds a test run result base on the passed in arguments\n *\n */\nexport const runResult = (\n  item:TTestObj,\n  {\n    id,\n    tests,\n    stats,\n    action,\n    failed,\n    passed,\n    testPath,\n    fullName,\n    describes,\n  }:TRunResultTestMeta\n) => {\n\n  const result:TRunResult = {\n    id,\n    stats,\n    action,\n    testPath,\n    fullName,\n    type: item.type,\n    failedExpectations: [],\n    passedExpectations: [],\n    failed: Boolean(failed),\n    passed: Boolean(passed),\n    description: item.description,\n    timestamp: new Date().getTime(),\n  }\n\n  if(tests?.length) result.tests = tests\n  if(describes?.length) result.describes = describes\n\n  isObj(failed) && result.failedExpectations.push(failed)\n  isObj(passed) && result.passedExpectations.push(passed)\n\n  isObj(item?.action?.ParkinMetaData)\n    ? (result.metaData = item?.action?.ParkinMetaData)\n    : isObj(item?.action?.metaData)\n        && (result.metaData = item?.action?.metaData)\n\n  if (passed || failed)\n    result.status = passed\n      ? EResultStatus.passed\n      : result?.metaData?.warnOnFailed\n        ? EResultStatus.warning\n        : EResultStatus.failed\n\n  return result\n}\n","import type {\n  TType,\n  TTestStats,\n  TRunResult,\n  TRootTestObj,\n  TTestTestObj,\n  TParkinHookCB,\n  TDescribeTestObj,\n} from '../types'\n\n\nimport { Types } from './utils'\nimport { runResult } from './runResult'\nimport { EResultStatus, EResultAction, ETestType } from '../types'\n\ntype TLoopHooks = {\n  test?:TTestTestObj\n  type: keyof TType\n  stats:TTestStats\n  describe?:TDescribeTestObj\n  specId?:keyof TType|string\n  suiteId?:keyof TType|string\n  root?: TRootTestObj|TDescribeTestObj\n}\n\nexport type TDescribeHooks = {\n  suiteId:string\n  stats:TTestStats\n  type:`before`|`after`\n  describe:TDescribeTestObj\n  describeResult:TRunResult\n  root:TDescribeTestObj | TRootTestObj\n  onSuiteDone:(result: TRunResult) => void\n}\n\n/**\n * Helper to loop over hooks and call them\n * @param {Object} args - Data for calling the passed in hook by type\n *\n * @returns {Object} - Built run result object if a hook fails\n */\nexport const loopHooks = async (args:TLoopHooks) => {\n  const {\n    type,\n    test,\n    root,\n    stats,\n    specId,\n    suiteId,\n    describe,\n  } = args\n\n  let hookResults:TRunResult[] = []\n\n  let hookIdx\n  const activeItem = root || describe\n  const fullName = root\n    ? root.description\n    : test\n      ? `${describe?.description} > ${test?.description} > ${type}`\n      : `${describe?.description} > ${type}`\n\n\n  activeItem[type].length &&\n    await Promise.all(\n      activeItem[type].map(async (fn:TParkinHookCB, idx:number) => {\n        hookIdx = idx\n        return await Promise.resolve()\n          .then(() => fn?.())\n          .catch((error:Error) => {\n            hookResults.push(\n              runResult(activeItem, {\n                stats,\n                fullName,\n                action: type as EResultAction,\n                id: test ? specId : suiteId,\n                status: EResultStatus.failed,\n                failed: {\n                  error,\n                  fullName,\n                  description: error.message,\n                  status: EResultStatus.failed,\n                },\n                testPath: test\n                  ? `/${suiteId}/${specId}/${type}${hookIdx}`\n                  : `/${suiteId}/${type}${hookIdx}`,\n              })\n            )\n          })\n      })\n    )\n\n  return hookResults\n}\n\n\n/**\n * Helper to call the before hooks from the root and current describe\n * @param {Object} args - Arguments needed to call the before hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nconst callBeforeHooks = async ({ root, suiteId, describe, stats }) => {\n  const beforeEachResult = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.beforeEach,\n  })\n\n  const beforeAllResult = await loopHooks({\n    stats,\n    suiteId,\n    describe,\n    type: Types.beforeAll,\n  })\n\n  return [...beforeEachResult, ...beforeAllResult]\n}\n\n/**\n * Helper to call the after hooks from the root and current describe\n * @param {Object} args - Arguments needed to call the after hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nconst callAfterHooks = async ({ root, suiteId, describe, stats }) => {\n  const afterEachResult = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.afterEach,\n  })\n\n  const afterAllResult = await loopHooks({\n      stats,\n      suiteId,\n      describe,\n      type: Types.afterAll,\n    })\n\n  return [...afterEachResult, ...afterAllResult]\n}\n\n\n/**\n * Helper to call the before and after hooks for describe methods\n * @param {Object} args - Arguments needed to call the after hooks\n *\n * @returns {Object} - Built results if a hook throws an error\n */\nexport const callDescribeHooks = async (args:TDescribeHooks) => {\n  const {\n    root,\n    type,\n    stats,\n    suiteId,\n    describe,\n    onSuiteDone,\n    describeResult\n  } = args\n\n  const results:TRunResult[] = []\n\n  const hooksResults = type === `before`\n    ? await callBeforeHooks({root, suiteId, describe, stats })\n    : await callAfterHooks({root, suiteId, describe, stats })\n  \n  if(!hooksResults?.length) return results\n  \n  if (hooksResults?.length) {\n    const describeResults = await Promise.all(\n      hooksResults.map(async (result) => {\n        const joined = {...describeResult, ...result, failed: true, passed: false }\n        await onSuiteDone(joined)\n\n        return joined\n      })\n    )\n\n    results.push(...describeResults)\n  }\n\n  return results\n}","import { wait } from \"@keg-hub/jsutils\"\nimport { TPromiseRetry } from \"../types\"\nimport { RetryError, throwAbortError } from './errors'\n\n// import { TAbortPromise } from \"../types\"\n// import { PromiseAbort } from './promiseAbort'\n// ----- Uncomment to add a PromiseAbort wrapper -----\n// Still working out how to do this properly, needs some work\n// export const PromiseRetry = <T=any>(opts:TPromiseRetry<T>): TAbortPromise<T> => {\n//   return PromiseAbort({\n//     promise: (args) => loopRetry({...opts, ...args}, opts?.retry || 0)\n//   })\n// }\n\nconst loopRetry = async <T=any>(opts:TPromiseRetry<T>, orgRetry?:number): Promise<T> => {\n  const {\n    delay=0,\n    retry=0,\n    onRetry,\n    controller,\n    promise:fn,\n    shouldAbort,\n  } = opts\n\n  const signal = controller?.signal\n\n  try {\n    const resp = await fn(opts)\n    return signal?.aborted || shouldAbort?.()\n      ?  throwAbortError()\n      : resp\n  }\n  catch (err) {\n    if(signal?.aborted || shouldAbort?.()) return throwAbortError()\n\n    if (retry <= 0) throw new RetryError(err, opts?.error, orgRetry)\n\n    const next = {...opts, retry: retry - 1}\n    onRetry && await onRetry?.(next)\n    delay && await wait(delay)\n\n    return loopRetry(next, orgRetry)\n  }\n}\n\nexport const PromiseRetry = async <T=any>(opts:TPromiseRetry<T>): Promise<T> => loopRetry(\n  opts,\n  opts?.retry || 0\n)\n\n","import { TPromiseTimeout } from \"../types\"\n\nclass TimeoutError extends Error {\n  constructor(message:string, name?:string) {\n    super(message)\n    this.name = name || this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n\nexport const PromiseTimeout = async <T=any>({\n  name,\n  error,\n  promise,\n  timeout=5000,\n}:TPromiseTimeout<T>):Promise<T> => {\n  const method = name ? `${name} method` : `method`\n\n  let timer:NodeJS.Timeout\n  const timePromise = new Promise((res, rej) => {\n    timer = setTimeout(() => rej(\n      new TimeoutError(\n        error || `The ${method} timed out after ${timeout} ms.`,\n        `TimeoutError`\n      )\n    ), timeout)\n  })\n\n  return await Promise.race([promise, timePromise] as [Promise<T>, Promise<any>])\n    .finally(() => clearTimeout(timer))\n}\n","import type { TPromiseRetry, TRunResult, TTestTestObj } from \"src/types\"\n\nimport { throwAbortError } from '../utils/errors'\nimport { PromiseRetry } from '../utils/promiseRetry'\nimport { PromiseTimeout } from '../utils/promiseTimeout'\n\nexport type TRunTest = Omit<TPromiseRetry<TRunResult>, `promise`> & {\n  test:TTestTestObj\n  shouldAbort:() => boolean\n}\n\n/**\n * Wraps the test.action in a Promise timeout and a Promise retry\n * Promise retry wraps the timeout, so each retry gets the same amount of time to resolve\n */\nexport const runTest = async (args:TRunTest) => {\n  const {test, shouldAbort, ...rest} = args\n\n  return PromiseRetry({\n    ...rest,\n    retry: test.retry || rest.retry || 0,\n    promise: async () => {\n      const promise = test.action()\n      shouldAbort() && throwAbortError()\n\n      /**\n        * If there is a timeout, Use the PromiseTimeout to race it against the test action\n        * If the timeout wins, it will reject the promise\n        * Which then gets picked up in the catch below\n        */\n      return test.timeout\n        ? await PromiseTimeout<TRunResult>({\n            promise,\n            timeout: test.timeout,\n            name: test.description,\n            error: `Test failed, the timeout ${test.timeout}ms was exceeded`\n          })\n        : await promise\n    }\n  })\n\n}","import type {\n  TTestTestObj,\n  TDescribeTestObj,\n} from \"../types\"\n\nexport type TShouldSkipTest = {\n  testOnly?:boolean\n  test: TTestTestObj\n  hasFailed?:boolean\n  skipAfterFailed?:boolean\n}\n\nexport type TBuildTestArgs = {\n  suiteId:string\n  testIdx:number\n  describe:TDescribeTestObj\n}\n\nexport type TShouldSkipDescribe = {\n  testOnly?:boolean\n  describeOnly?:boolean\n  describe: TDescribeTestObj\n}\n\n\nexport const shouldSkipTest = (params:TShouldSkipTest) => {\n  const {\n    test,\n    testOnly,\n    hasFailed,\n    skipAfterFailed\n  } = params\n\n  return test.skip\n    || (testOnly && !test.only)\n    || (hasFailed && skipAfterFailed)\n}\n\nexport const buildTestArgs = ({\n  suiteId,\n  testIdx,\n  describe\n}:TBuildTestArgs) => {\n  const test = describe.tests[testIdx]\n  const specId = `spec-${testIdx}`\n\n  return {\n    test,\n    specId,\n    testPath: `/${suiteId}/${specId}`,\n    fullName: `${describe.description} > ${test.description}`,\n  }\n}\n\n\nexport const shouldSkipDescribe = ({ describe, describeOnly, testOnly }:TShouldSkipDescribe) => {\n  return describe.skip ||\n    (describeOnly && !describe.only && !describe.onlyChild) ||\n    (testOnly && !describe.onlyChild)\n}","import type { TLoopTests, TRunResult, TRunResults } from '../types'\n\nimport { Types } from './utils'\n\nimport { runTest } from './runTest'\nimport { loopHooks } from './hooks'\nimport { runResult } from './runResult'\nimport { ParkinAbortErrName } from '../constants'\nimport { throwAbortError } from '../utils/errors'\nimport { EResultStatus, EResultAction } from '../types'\nimport { throwBailError, throwExitOnFailed } from '../utils/errors'\n\nimport {\n  buildTestArgs,\n  shouldSkipTest,\n} from './runHelpers'\n\n\n/**\n * Helper to loop over tests and call their test method\n *\n * @returns {Object} - Built run result object of the test results\n */\nexport const loopTests = async (args:TLoopTests) => {\n  const {\n    bail,\n    stats,\n    suiteId,\n    describe,\n    testOnly,\n    onSpecDone,\n    testRetry,\n    onTestRetry,\n    shouldAbort,\n    onSpecStart,\n    exitOnFailed,\n    skipAfterFailed,\n  } = args\n\n  let testsFailed = false\n  const results:TRunResults = []\n\n  // ------ describe - loop tests ------ //\n  for (let testIdx = 0; testIdx < describe.tests.length; testIdx++) {\n\n    shouldAbort() && throwAbortError()\n\n    const {\n      test,\n      specId,\n      testPath,\n      fullName,\n    } = buildTestArgs({ suiteId, testIdx, describe })\n\n    let testResult = runResult(test, {\n      stats,\n      fullName,\n      testPath,\n      id: specId,\n      action: EResultAction.start,\n    })\n\n    const shouldSkip = shouldSkipTest({\n      test,\n      testOnly,\n      skipAfterFailed,\n      hasFailed: testsFailed\n    })\n\n    if(shouldSkip){\n      const skipped = {\n        ...testResult,\n        skipped: true,\n        action: EResultAction.skipped,\n        status: EResultStatus.skipped,\n      }\n\n      await onSpecStart(skipped)\n      results.push(skipped)\n      continue\n    }\n    else await onSpecStart(testResult)\n\n    shouldAbort() && throwAbortError()\n\n    const beforeEachResults = await loopHooks({\n      test,\n      stats,\n      specId,\n      suiteId,\n      describe,\n      type: Types.beforeEach,\n    })\n\n    if (beforeEachResults?.length) {\n      testsFailed = true\n      results.push(...beforeEachResults)\n      beforeEachResults.forEach(onSpecDone)\n      break\n    }\n\n    // ------ execute test ------ //\n    try {\n\n      /**\n       * If there is a timeout, Use the PromiseTimeout to race it against the test action\n       * If the timeout wins, it will reject the promise\n       * Which then gets picked up in the catch below\n       */\n      const result = await runTest({\n        test,\n        shouldAbort,\n        retry: testRetry,\n        onRetry: onTestRetry,\n      })\n      \n      shouldAbort() && throwAbortError()\n\n      // If we get to here, the test passed, so up the passed spec count\n      stats.passedSpecs += 1\n\n      testResult = runResult(test, {\n        stats,\n        fullName,\n        id: specId,\n        testPath: testPath,\n        passed: result || true,\n        action: EResultAction.test,\n      })\n\n    }\n    catch (error) {\n\n      if(error.name === ParkinAbortErrName) throw error\n\n      testsFailed = true\n      stats.failedSpecs += 1\n\n      testResult = runResult(test, {\n        stats,\n        fullName,\n        id: specId,\n        testPath: testPath,\n        action: EResultAction.test,\n        failed: {\n          error,\n          fullName,\n          description: error.message,\n          status: EResultStatus.failed,\n        },\n      })\n\n      const shouldBail = Boolean(bail && stats.failedSpecs >= bail)\n      if(exitOnFailed || shouldBail){\n        results.push(testResult)\n        error.testResults = results\n        await onSpecDone(testResult)\n\n        exitOnFailed && throwExitOnFailed(error)\n        shouldBail && throwBailError(error, bail)\n        break\n      }\n\n    }\n    \n    shouldAbort() && throwAbortError()\n\n    const afterEachResults = await loopHooks({\n      test,\n      stats,\n      specId,\n      suiteId,\n      describe,\n      type: Types.afterEach,\n    })\n    if (afterEachResults?.length) {\n      testsFailed = true\n      results.push(...afterEachResults)\n      afterEachResults.forEach(onSpecDone)\n      break\n    }\n\n    results.push(testResult)\n\n    await onSpecDone({\n      ...testResult,\n      action: EResultAction.end\n    })\n\n  }\n\n  shouldAbort() && throwAbortError()\n\n  return { tests: results, failed: testsFailed }\n\n}\n","import type {\n  TRun,\n  TRunResult,\n  TTestStats,\n  TRunResults,\n  TParkinTestCB,\n  TDescribeTestObj,\n} from '../types'\n\nimport { runResult } from './runResult'\nimport { loopTests } from './loopTests'\nimport { callDescribeHooks } from './hooks'\nimport { ParkinAbortErrName } from '../constants'\nimport { shouldSkipDescribe } from './runHelpers'\nimport { EResultStatus, EResultAction } from '../types'\n\nexport type TLoopChildren<T=any> = {\n  stats:TTestStats\n  describeResult:TRunResult\n  onSuiteDone:TParkinTestCB\n  describe:TDescribeTestObj\n  loopFun:() => Promise<{tests?: TRunResults, describes?: TRunResults, failed: boolean }>\n}\n\n/**\n * Helper method to loop over children of a describe test object\n */\nconst loopChildren = async (args:TLoopChildren) => {\n  const {\n    stats,\n    describe,\n    onSuiteDone,\n    describeResult,\n    loopFun,\n  } = args\n\n  try {\n    const results = await loopFun()\n    const failed = results?.failed || describeResult?.failed\n\n    const joined = {\n      ...describeResult,\n      ...results,\n      action: EResultAction.end,\n    }\n    if(failed) joined.failed = failed\n\n    return joined\n  }\n  /**\n    * This will catch if an error is thrown by something other then a test or a hook\n    * For example Parkin Bail Error, or Parkin abort error is thrown, then it will show up here\n    * For abort errors we just rethrow the error, but for Bail errors\n    * We capture it so we can still call the onSuiteEnd callback, then rethrow the error\n    */\n  catch(err){\n    if(err.name === ParkinAbortErrName) throw err\n\n    stats.failedSuites += 1\n    const errorResult = runResult(describe, {\n      ...describeResult,\n      stats,\n      action: EResultAction.end,\n      failed: {\n        error: err,\n        description: err.message,\n        status: EResultStatus.failed,\n        fullName: describe.description,\n      }\n    })\n\n    // If there's testsResults\n    // Store them in the describe result, and remove them from the error\n    if(err.testResults){\n      errorResult.tests = err.testResults\n      err.testResults = undefined\n    }\n\n    await onSuiteDone(errorResult)\n\n    err.results = err.results || []\n    err.results.push(errorResult)\n\n    throw err\n  }\n\n}\n\n/**\n * Helper to loop over describe methods and call child tests\n * @param {Object} args - Config to overwrite the initial test config object\n *\n * @returns {Object} - Built run results of the test results\n */\nexport const loopDescribes = async (args:TRun) => {\n  const {\n    root,\n    bail,\n    stats,\n    testOnly,\n    testRetry,\n    onSpecDone,\n    onSuiteDone,\n    shouldAbort,\n    onTestRetry,\n    onSpecStart,\n    onSuiteStart,\n    describeOnly,\n    parentIdx = ``,\n    exitOnFailed,\n    skipAfterFailed,\n  } = args\n\n  let describeFailed = false\n  const results:TRunResults = []\n\n\n  // ------ loop describes ------ //\n  for (let idx = 0; idx < root.describes.length; idx++) {\n\n    if(shouldAbort()) break\n\n    const describe = root.describes[idx]\n    const suiteId = `suite-${parentIdx}${idx}`\n\n    // Create a runResult with general information that can be reused below\n    let describeResult = runResult(describe, {\n      stats,\n      id: suiteId,\n      testPath: `/${suiteId}`,\n      action: EResultAction.start,\n      fullName: describe.description,\n    })\n\n\n    if (shouldSkipDescribe({ describe, describeOnly, testOnly })) {\n      await onSuiteStart({\n        ...describeResult,\n        skipped: true,\n        action: EResultAction.skipped,\n        status: EResultStatus.skipped,\n      })\n      continue\n    }\n    else await onSuiteStart(describeResult)\n\n    const beforeResults = await callDescribeHooks({\n      root,\n      stats,\n      suiteId,\n      describe,\n      onSuiteDone,\n      describeResult,\n      type: `before`,\n    })\n\n    if (beforeResults?.length) {\n      describeFailed = true\n      results.push(...beforeResults)\n      continue\n    }\n\n    if(shouldAbort()) break\n\n    // Loop over any test children\n    describeResult = describe?.tests?.length\n      ? await loopChildren({\n          stats,\n          describe,\n          onSuiteDone,\n          describeResult,\n          loopFun: async () => await loopTests({\n            bail,\n            stats,\n            suiteId,\n            describe,\n            testOnly,\n            onSpecDone,\n            testRetry,\n            onTestRetry,\n            shouldAbort,\n            onSpecStart,\n            exitOnFailed,\n            skipAfterFailed,\n          })\n        })\n      : describeResult\n\n    if(exitOnFailed && describeResult.failed){\n      describeFailed = true\n      stats.failedSuites += 1\n      await onSuiteDone(describeResult)\n      results.push(describeResult)\n      break\n    }\n\n    // Loop over any describe children\n    describeResult = describe?.describes?.length\n      ? await loopChildren({\n          stats,\n          describe,\n          onSuiteDone,\n          describeResult,\n          loopFun: async () => await loopDescribes({\n            ...args,\n            root: describe,\n            parentIdx: `${idx}-`,\n          })\n        })\n      : describeResult\n\n    describeResult.failed\n      ? (stats.failedSuites += 1)\n      : (stats.passedSuites += 1)\n\n    if(exitOnFailed && describeResult.failed){\n      describeFailed = true\n      await onSuiteDone(describeResult)\n      results.push(describeResult)\n      break\n    }\n\n    if(shouldAbort()) break\n\n    if (describeResult.failed) {\n      describeFailed = true\n      describeResult.failed = true\n      describeResult.status = EResultStatus.failed\n    }\n    else {\n      describeResult.passed = true\n      describeResult.status = EResultStatus.passed\n    }\n\n    const afterResults = await callDescribeHooks({\n      root,\n      stats,\n      suiteId,\n      describe,\n      onSuiteDone,\n      describeResult,\n      type: `after`,\n    })\n\n    if (afterResults?.length) {\n      describeFailed = true\n      results.push(...afterResults)\n      continue\n    }\n\n    if(shouldAbort()) break\n\n    await onSuiteDone(describeResult)\n    results.push(describeResult)\n  }\n\n  return shouldAbort()\n    ? { describes: [], failed: describeFailed }\n    : { describes: results, failed: describeFailed }\n\n}\n","import type {\n  TRun,\n  TRunResults,\n  TRootTestObj,\n} from '../types'\n\nimport { loopHooks } from './hooks'\nimport { runResult } from './runResult'\n\nimport { ParkinError } from '../utils/errors'\nimport { ParkinBailErrName, ParkinAbortErrName } from '../constants'\nimport { loopDescribes } from './loopDescribes'\nimport { Types, validateRootRun } from './utils'\nimport { EResultStatus, EResultAction } from '../types'\n\n/**\n * Executes all methods registered to the ParkinTest instance\n * @param {Object} args - Config to overwrite the initial test config object\n *\n * @returns {Object} - Results of the test run\n */\nexport const run = async (args:TRun):Promise<TRunResults> => {\n  const {\n    root,\n    stats,\n    onAbort,\n    onRunDone,\n    shouldAbort,\n    onRunStart,\n  } = args\n\n  let bailError:ParkinError\n  let describesFailed:boolean\n  let describes:TRunResults = []\n\n\n  validateRootRun(root as TRootTestObj)\n  // Create a runResult with general information that can be reused below\n  let rootResult = runResult(root, {\n    stats,\n    id: Types.root,\n    fullName: root.description,\n    testPath: `/${Types.root}`,\n  })\n\n  await onRunStart({\n    ...rootResult,\n    stats,\n    action: EResultAction.start,\n    description: `Starting test execution`,\n  })\n\n  const beforeAllResults = await loopHooks({\n    root,\n    stats,\n    suiteId: Types.root,\n    type: Types.beforeAll,\n  })\n\n  if(shouldAbort()){\n    await onAbort?.()\n    stats.runEnd = new Date().getTime()\n    await onRunDone({\n      ...rootResult,\n      stats,\n      action: EResultAction.abort,\n      description: `Test execution aborted`,\n    })\n\n    describes.aborted = true\n    return Object.assign(describes, stats)\n  }\n\n  // If a before all throws an error, we don't want to run the rest of the tests, so just return\n  if (beforeAllResults?.length) return Object.assign(beforeAllResults, stats)\n\n  // Ensure the afterAll hooks are always called\n  // Wrap the loopDescribes in a ty/catch/finally to ensure they are called at the end\n  try {\n    const resp = await loopDescribes(args)\n    describes = resp.describes\n    describesFailed = resp.failed\n\n    if(shouldAbort()){\n      await onAbort?.()\n      stats.runEnd = new Date().getTime()\n      await onRunDone({\n        ...rootResult,\n        stats,\n        action: EResultAction.abort,\n        description: `Test execution aborted`,\n      })\n      describes.aborted = true\n    }\n  }\n  catch(err){\n    describesFailed = true\n    const isBailErr = err.name === ParkinBailErrName\n    const isAbortErr = err.name === ParkinAbortErrName\n\n    bailError = isBailErr || isAbortErr ? err : undefined\n\n    if(isBailErr) describes.bailed = true\n    if(isAbortErr) describes.aborted = true\n\n    err.results\n      ? describes.push(...err.results)\n      : describes.push(runResult(root, {\n            stats,\n            describes,\n            id: Types.root,\n            fullName: root.description,\n            testPath: `/${Types.root}`,\n            action: EResultAction.end,\n            status: EResultStatus.failed,\n            failed: {\n              error: err,\n              description: err.message,\n              fullName: root.description,\n              status: EResultStatus.failed,\n            }\n        })\n      )\n\n  }\n  finally {\n    const afterAllResult = await loopHooks({\n      root,\n      stats,\n      suiteId: Types.root,\n      type: Types.afterAll,\n    })\n    afterAllResult?.length && describes.push(...afterAllResult)\n    stats.runEnd = stats.runEnd || new Date().getTime()\n\n    await onRunDone({\n      ...rootResult,\n      stats,\n      describes,\n      failed: describesFailed,\n      passed: !describesFailed,\n      action: EResultAction.end,\n      description: `Test execution complete`,\n      status: describesFailed ? EResultStatus.failed : EResultStatus.passed\n    })\n\n    if(bailError){\n      // After joining the error results with the already captured results\n      // Ensure the stats object is added as well\n      bailError.results = Object.assign(describes, stats)\n      throw bailError\n    }\n  }\n\n  return Object.assign(describes, stats)\n}\n","import type {\n  TRunResult,\n  TRunResults,\n  TTestAction,\n  TTestTestObj,\n  TParkinTestCB,\n  TParentTestObj,\n  TTestHookMethod,\n  TPromiseRetryCB,\n  TDescribeAction,\n  TParkinTestAbort,\n  TParkinTestConfig,\n  TParkinTestFactory,\n  TRunResultActionMeta,\n  TParkinDescribeFactory,\n} from '../types'\n\nimport { run } from './run'\nimport { runResult } from './runResult'\nimport { PromiseRetry } from '../utils/promiseRetry'\nimport { PromiseTimeout } from '../utils/promiseTimeout'\nimport { noOp, noOpObj, isStr, checkCall, isNum, isObj, exists } from '@keg-hub/jsutils'\nimport {\n  Types,\n  createRoot,\n  createItem,\n  createDescribe,\n  throwError,\n  hookTypes,\n  validateHook,\n} from './utils'\n\ntype TTestSkipFactory = (description:string, action?:TTestAction, timeout?:number) => void\n\nexport class ParkinTest {\n  // Defaults set to 0, is the same as disabled\n  bail = 0\n  testRetry = 0\n  suiteRetry = 0\n  #onTestRetry:TPromiseRetryCB<TRunResult>\n  #onSuiteRetry:TPromiseRetryCB<TRunResults>\n\n  // Default test timeout to be 5 seconds\n  testTimeout = 5000\n  // Default suite test timeout is 1hr\n  suiteTimeout = 3600000\n  #autoClean = true\n  #testOnly = false\n  #abortRun = false\n  #describeOnly = false\n  #exitOnFailed = false\n  #skipAfterFailed = false\n  #root = createRoot()\n  xit:TTestSkipFactory\n  it:TParkinTestFactory\n  #onRunDone:TParkinTestCB = noOp\n  #onRunStart:TParkinTestCB = noOp\n  #onSpecDone:TParkinTestCB = noOp\n  #onSuiteDone:TParkinTestCB = noOp\n  #onSpecStart:TParkinTestCB = noOp\n  #onSuiteStart:TParkinTestCB = noOp\n  #onAbort:TParkinTestAbort = noOp\n  afterAll:TTestHookMethod = noOp\n  afterEach:TTestHookMethod = noOp\n  beforeAll:TTestHookMethod = noOp\n  beforeEach:TTestHookMethod = noOp\n  #activeParent:TParentTestObj = undefined\n\n  constructor(config:TParkinTestConfig = noOpObj) {\n    this.#root.description = config.description || `root`\n\n    this.#addOnly()\n    this.#addSkip()\n    this.#addHelpers()\n    this.it = this.test\n    this.xit = this.xtest\n    this.#activeParent = this.#root\n    this.setConfig(config)\n  }\n\n  run = (config:TParkinTestConfig = noOpObj) => {\n\n    if (config.description) this.#root.description = config.description\n\n    this.setConfig(config)\n    const runSuite = async () => {\n      const promise = run({\n        bail: this.bail,\n        root: this.#root,\n        onAbort: this.#onAbort,\n        testOnly: this.#testOnly,\n        testRetry: this.testRetry,\n        onRunDone: this.#onRunDone,\n        onRunStart: this.#onRunStart,\n        onSpecDone: this.#onSpecDone,\n        onSpecStart: this.#onSpecStart,\n        onTestRetry: this.#onTestRetry,\n        shouldAbort: this.#shouldAbort,\n        onSuiteDone: this.#onSuiteDone,\n        onSuiteStart: this.#onSuiteStart,\n        exitOnFailed: this.#exitOnFailed,\n        describeOnly: this.#describeOnly,\n        skipAfterFailed: this.#skipAfterFailed,\n        stats: {\n          runEnd: 0,\n          failedSpecs: 0,\n          passedSpecs: 0,\n          passedSuites: 0,\n          failedSuites: 0,\n          runStart: new Date().getTime(),\n        },\n      })\n\n      const result = this.suiteTimeout\n        ? PromiseTimeout<TRunResults>({\n            promise,\n            timeout: this.suiteTimeout,\n            name: this.#root.description,\n            error: `Test Execution failed, the suite timeout ${this.suiteTimeout}ms was exceeded`\n          })\n        : promise\n\n      this.#autoClean && this.clean()\n\n      return result\n    }\n\n    return PromiseRetry({\n      promise: runSuite,\n      retry: this.suiteRetry,\n      onRetry: this.#onSuiteRetry\n    })\n  }\n\n  /**\n   * Expose the helper method to build a test result\n   * Helpful in cases where ParkinTest is wrapped by another tool\n   * Allows for a consistent iterface of events\n   */\n  buildResult = runResult\n\n  #shouldAbort = () => this.#abortRun\n\n  abort = () => {\n    this.#abortRun = true\n  }\n\n  /**\n   * Resets the instance to it's initial state\n   * Clears all previously loaded tests and describes\n   */\n  clean = () => {\n    this.testTimeout = 5000\n    this.suiteTimeout = 3600000\n    this.#autoClean = true\n    this.#abortRun = false\n    this.#testOnly = false\n    this.#describeOnly = false\n\n    this.#activeParent = undefined\n    this.#root = undefined\n    this.#root = createRoot()\n    this.#activeParent = this.#root\n  }\n\n  /**\n   * Gets the current activeParent, which should almost always be this.#root\n   */\n  getActiveParent = () => {\n    return this.#activeParent\n  }\n\n  /**\n   * Adds passed in framework hooks to the class instance\n   */\n  setConfig = ({\n    bail,\n    timeout,\n    testRetry,\n    suiteRetry,\n    testTimeout,\n    suiteTimeout,\n    onTestRetry,\n    onSuiteRetry,\n    exitOnFailed,\n    skipAfterFailed,\n    onAbort,\n    autoClean,\n    onSpecDone,\n    onSuiteDone,\n    onRunDone,\n    onRunStart,\n    onSpecStart,\n    onSuiteStart,\n  }:TParkinTestConfig=noOpObj) => {\n\n    if(onAbort) this.#onAbort = onAbort\n    \n    if(isNum(testTimeout)) this.testTimeout = testTimeout\n    else if(isNum(timeout)) this.testTimeout = timeout\n\n    if(isNum(suiteTimeout)) this.suiteTimeout = suiteTimeout\n    else if(isNum(timeout)) this.suiteTimeout = timeout\n\n    if (isNum(bail)) this.bail = bail\n    if (isNum(testRetry)) this.testRetry = testRetry\n    if (isNum(suiteRetry)) this.suiteRetry = suiteRetry\n\n    if (onTestRetry) this.#onTestRetry = onTestRetry\n    if (onSuiteRetry) this.#onSuiteRetry = onSuiteRetry\n\n    if (onSpecDone) this.#onSpecDone = onSpecDone\n    if (onSpecStart) this.#onSpecStart = onSpecStart\n\n    if (onSuiteDone) this.#onSuiteDone = onSuiteDone\n    if (onSuiteStart) this.#onSuiteStart = onSuiteStart\n\n    if (onRunDone) this.#onRunDone = onRunDone\n    if (onRunStart) this.#onRunStart = onRunStart\n\n    if (autoClean === false) this.#autoClean = autoClean\n\n    if(exitOnFailed) this.#exitOnFailed = exitOnFailed\n    if(skipAfterFailed) this.#skipAfterFailed = skipAfterFailed\n  }\n\n  /**\n   * Adds the only method to describe and test methods\n   * Ensures they are the only methods called when run\n   */\n  #addOnly = () => {\n\n    this.describe.only = (...args:[string, TDescribeAction]) => {\n      this.describe(...args)\n      // Get the last item just added to the this.#activeParent\n      const item =\n        this.#activeParent.describes[this.#activeParent.describes.length - 1]\n      item.only = true\n      this.#describeOnly = true\n      // Call the parent hasOnlyChild method to ensure it gets passed on the chain\n      checkCall(this.#activeParent.hasOnlyChild)\n    }\n\n    this.test.only = (...args:[description:string, action?:TTestAction, meta?:TRunResultActionMeta|number]) => {\n      this.test(...args)\n      // Get the last item just added to the this.#activeParent\n      const item = this.#activeParent.tests[this.#activeParent.tests.length - 1]\n      item.only = true\n      this.#testOnly = true\n      // Call the parent hasOnlyChild method to ensure it gets passed on the chain\n      checkCall(this.#activeParent.hasOnlyChild)\n    }\n  }\n\n  /**\n   * Adds the skip method to describe and test methods\n   * Ensures they are skipped run method is called\n   */\n  #addSkip = () => {\n\n    this.describe.skip = (...args:[string, TDescribeAction]) => {\n      this.describe(...args)\n      // Get the last item just added to the this.#activeParent\n      const item =\n        this.#activeParent.describes[this.#activeParent.describes.length - 1]\n      item.skip = true\n    }\n\n    this.test.skip = (...args:[description:string, action?:TTestAction, meta?:TRunResultActionMeta|number]) => {\n      this.test(...args)\n      // Get the last item just added to the this.#activeParent\n      const item = this.#activeParent.tests[this.#activeParent.tests.length - 1]\n      item.skip = true\n    }\n  }\n\n  /**\n   * TODO: @lance-Tipton\n   * Add each methods to describe and test\n   */\n  #addEach = () => {}\n\n  /**\n   * Adds the helper methods to the class instance\n   * Methods: beforeAll, beforeEach, afterAll, afterEach\n   */\n  #addHelpers = () => {\n    Object.values(hookTypes).map(type => {\n      this[type] = (action) => {\n        validateHook(type, action)\n        this.#activeParent[type].push(action)\n      }\n    })\n  }\n\n  /**\n   * Method the wraps test and helper methods\n   * Acts as a top level method for defining tests\n   *\n   * @returns {void}\n   */\n  describe = ((\n    description:string,\n    action:TDescribeAction\n  ) => {\n\n    // Build the describe item and add defaults\n    const item = createDescribe(description, action)\n    this.#activeParent.describes.push(item)\n\n    // Cache the lastParent, so we can reset it\n    const lastParent = this.#activeParent\n\n    item.hasOnlyChild = () => {\n      item.onlyChild = true\n      checkCall(lastParent.hasOnlyChild)\n    }\n\n    // Set the current activeParent to the item\n    this.#activeParent = item\n\n    // Call the action to register all test method calls while the items active\n    action()\n\n    // Reset the last activeParent\n    // Should end up with the #root being the final activeParent\n    this.#activeParent = lastParent\n  }) as TParkinDescribeFactory\n\n  /**\n   * Method that executes some test logic\n   * Must be called within a Test#describe method\n   *\n   * @returns {void}\n   */\n  test = ((\n    description:string,\n    action:TTestAction,\n    meta:TRunResultActionMeta|number\n  ) => {\n\n    let retry:number = this.testRetry || 0\n    let timeout:number = this.testTimeout\n\n    if(isObj(meta) && !exists(action.metaData) && !exists(action.ParkinMetaData)){\n      action.metaData = meta\n      if(meta?.timeout) timeout = meta.timeout\n      if(meta?.retry) retry = meta.retry\n    }\n    else if(isNum(meta)) timeout = meta\n\n    if (!this.#activeParent || this.#activeParent.type === Types.root)\n      throwError(`All ${Types.test} method calls must be called within a ${Types.describe} method`)\n\n    const item = createItem<TTestTestObj>(\n      Types.test,\n      {\n        retry,\n        action,\n        timeout,\n        description\n      }\n    )\n\n    item.disabled = () => (item.skip = true)\n\n    this.#activeParent.tests.push(item)\n  }) as TParkinTestFactory\n\n  /**\n   * Called when a test method should be skipped\n   * Must be called within a Test#describe method\n   *\n   * @returns {void}\n   */\n  xtest = (\n    description:string,\n    action?:TTestAction,\n    timeout?:number\n  ) => {\n    if (!this.#activeParent || this.#activeParent.type === Types.root)\n      throwError(\n        `All ${Types.test} method calls must be called within a ${Types.describe} method`\n      )\n\n    !isStr(description) &&\n      throwError(\n        `The ${Types.test} method requires a \"string\" as the first argument`\n      )\n    const item = createItem<TTestTestObj>(Types.test, { description, skip: true }, false)\n    item.disabled = () => (item.skip = true)\n\n    this.#activeParent.tests.push(item)\n  }\n\n}\n"],"mappings":"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","names":[]}